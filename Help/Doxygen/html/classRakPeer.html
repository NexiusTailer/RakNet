<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RakNet: RakPeer Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RakPeer Class Reference</h1><!-- doxytag: class="RakPeer" --><!-- doxytag: inherits="RakPeerInterface" -->Main interface for network communications.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;RakPeer.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for RakPeer:</div>
<div class="dynsection">

<p><center><img src="classRakPeer.png" usemap="#RakPeer_map" border="0" alt=""></center>
<map name="RakPeer_map">
<area href="classRakPeerInterface.html" alt="RakPeerInterface" shape="rect" coords="0,0,110,24">
</map>
</div>

<p>
<a href="classRakPeer-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff7ebc01fb71df027b1a065ff63ca8b4"></a><!-- doxytag: member="RakPeer::RakPeer" ref="ff7ebc01fb71df027b1a065ff63ca8b4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ff7ebc01fb71df027b1a065ff63ca8b4">RakPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="db105b82e90bebddaa273ba7e6ba08ad"></a><!-- doxytag: member="RakPeer::~RakPeer" ref="db105b82e90bebddaa273ba7e6ba08ad" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#db105b82e90bebddaa273ba7e6ba08ad">~RakPeer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85">Startup</a> (unsigned short maxConnections, int _threadSleepTimer, <a class="el" href="structSocketDescriptor.html">SocketDescriptor</a> *socketDescriptors, unsigned socketDescriptorCount, int threadPriority=-99999)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the network threads and opens the listen port.  <a href="#1fbd8608cf1ead14250b293cc6eb9a85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#adcb268bdcd4751c304c8156c28eb66d">InitializeSecurity</a> (const char *pubKeyE, const char *pubKeyN, const char *privKeyP, const char *privKeyQ)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Secures connections though a combination of SHA1, AES128, SYN Cookies, and RSA to prevent connection spoofing, replay attacks, data eavesdropping, packet tampering, and MitM attacks.  <a href="#adcb268bdcd4751c304c8156c28eb66d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#bc9e3cd4ac407f23ce1ee99c94cabd88">DisableSecurity</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables all security.  <a href="#bc9e3cd4ac407f23ce1ee99c94cabd88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f8d5bea4ceaa700d451196b9b0b0ed25">AddToSecurityExceptionList</a> (const char *ip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is useful if you have a fixed-address internal server behind a LAN.  <a href="#f8d5bea4ceaa700d451196b9b0b0ed25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#24be36bb9b57fd85627d89b66b149c50">RemoveFromSecurityExceptionList</a> (const char *ip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a specific connection previously added via AddToSecurityExceptionList.  <a href="#24be36bb9b57fd85627d89b66b149c50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#4541da876eef1161bd7460f2cbfcc3bd">IsInSecurityExceptionList</a> (const char *ip)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see if a given IP is in the security exception list.  <a href="#4541da876eef1161bd7460f2cbfcc3bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d2004ca40f0a88ca24f70196321d48c8">SetMaximumIncomingConnections</a> (unsigned short numberAllowed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum number of incoming connections allowed.  <a href="#d2004ca40f0a88ca24f70196321d48c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5c413e010504007506d6be8bc27a2668">GetMaximumIncomingConnections</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value passed to <a class="el" href="classRakPeer.html#d2004ca40f0a88ca24f70196321d48c8" title="Sets the maximum number of incoming connections allowed.">SetMaximumIncomingConnections()</a>.  <a href="#5c413e010504007506d6be8bc27a2668"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#0155271445e2fe26b382080f228df46d">NumberOfConnections</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many open connections exist at this time.  <a href="#0155271445e2fe26b382080f228df46d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c">SetIncomingPassword</a> (const char *passwordData, int passwordDataLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the password for the incoming connections.  <a href="#a6daafe75bfe4882aa46f32cb753378c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3d16efedd2007d917e613a78f816baba">GetIncomingPassword</a> (char *passwordData, int *passwordDataLength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the password passed to SetIncomingPassword.  <a href="#3d16efedd2007d917e613a78f816baba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c7ba51ef72df78a7da4b7e6d5e2c8276">Connect</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNetTime timeoutTime=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port.  <a href="#c7ba51ef72df78a7da4b7e6d5e2c8276"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3341478f794ee257e957021834a41b71">ConnectWithSocket</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, RakNetSmartPtr&lt; RakNetSocket &gt; socket, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNetTime timeoutTime=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port.  <a href="#3341478f794ee257e957021834a41b71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ab69808cd87c19f1800ac36d8c8e584c">Shutdown</a> (unsigned int blockDuration, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=LOW_PRIORITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops the network threads and closes all connections.  <a href="#ab69808cd87c19f1800ac36d8c8e584c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#52ff3b23878d11d8b00473835d44b1f5">IsActive</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the network thread is running.  <a href="#52ff3b23878d11d8b00473835d44b1f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2f3e89dc1baf72e449911b7c674403fc">GetConnectionList</a> (<a class="el" href="structSystemAddress.html">SystemAddress</a> *remoteSystems, unsigned short *numberOfSystems) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fills the array remoteSystems with the <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> of all the systems we are connected to.  <a href="#2f3e89dc1baf72e449911b7c674403fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#826f37d914c04365cb3276e7d8598f88">GetNextSendReceipt</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#71721eb4963b3aa7d39816d9e21438b7">IncrementNextSendReceipt</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#cf41cc0dc46e2d9678504eed199a4815">Send</a> (const char *data, const int length, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a block of data to the specified system that you are connected to.  <a href="#cf41cc0dc46e2d9678504eed199a4815"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#888819dc988a3282c41db84ee0a00b6e">SendLoopback</a> (const char *data, const int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Send" to yourself rather than a remote system.  <a href="#888819dc988a3282c41db84ee0a00b6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#add1f66541b69c13191bd6b0a7e8daee">Send</a> (const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a block of data to the specified system that you are connected to.  <a href="#add1f66541b69c13191bd6b0a7e8daee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#70b2284bc6d741be7429570f3f3222bf">SendList</a> (const char **data, const int *lengths, const int numParameters, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends multiple blocks of data, concatenating them automatically.  <a href="#70b2284bc6d741be7429570f3f3222bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7">Receive</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a message from the incoming message queue.  <a href="#79fddb1f74db30833fc08687c1310ce7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f68f8d2766b45b6d951dfd62cf349a71">DeallocatePacket</a> (<a class="el" href="structPacket.html">Packet</a> *packet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this to deallocate a message returned by <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> when you are done handling it.  <a href="#f68f8d2766b45b6d951dfd62cf349a71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#23aa5e3e7f94cccd150392ff73233526">GetMaximumNumberOfPeers</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of connections we are allowed.  <a href="#23aa5e3e7f94cccd150392ff73233526"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41">RegisterAsRemoteProcedureCall</a> (const char *uniqueID, void(*functionPointer)(<a class="el" href="structRPCParameters.html">RPCParameters</a> *rpcParms))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a C or static member function as available for calling a remote procedure call.  <a href="group__RAKNET__RPC.html#gc253d708a039e60aa0aaafca3f9a1d41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gbd4e89c774e58f88754dfd6108b9c7d0">RegisterClassMemberRPC</a> (const char *uniqueID, void *functionPointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a C++ member function as available for calling as a remote procedure call.  <a href="group__RAKNET__RPC.html#gbd4e89c774e58f88754dfd6108b9c7d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g8d3118ee980a05022b9dd53a54b1f139">UnregisterAsRemoteProcedureCall</a> (const char *uniqueID)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a C function as available for calling as a remote procedure call that was formerly registered with RegisterAsRemoteProcedureCall. Only call offline.  <a href="group__RAKNET__RPC.html#g8d3118ee980a05022b9dd53a54b1f139"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#g3dd3a014e7e3ab37489fdc3d9c77d072">SetNetworkIDManager</a> (<a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *manager)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used by Object member RPC to lookup objects given that object's ID. Also used by the <a class="el" href="classReplicaManager.html" title="A management system for your game objects and players to make serialization, scoping...">ReplicaManager</a> plugin.  <a href="group__RAKNET__RPC.html#g3dd3a014e7e3ab37489fdc3d9c77d072"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#9c056f687a5be705c2d54ef2ca311243">GetNetworkIDManager</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gb26a0210cfe59ce179245b37d452c7ce">RPC</a> (const char *uniqueID, const char *data, BitSize_t bitLength, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__RAKNET__RPC.html#gbbe0b3eb71fcb07079cd3f1837663550">RPC</a> (const char *uniqueID, const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, RakNetTime *includedTimestamp, NetworkID networkID, <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *replyFromTarget)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls a C function on the remote system that was already registered using RegisterAsRemoteProcedureCall.  <a href="group__RAKNET__RPC.html#gbbe0b3eb71fcb07079cd3f1837663550"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#4a7c586a8be0d977354a3cfd09bab6b7">CloseConnection</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target, bool sendDisconnectionNotification, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=LOW_PRIORITY)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out).  <a href="#4a7c586a8be0d977354a3cfd09bab6b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#01b140bb9e6a90a0c1867a5101131fd1">CancelConnectionAttempt</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a pending connection attempt.  <a href="#01b140bb9e6a90a0c1867a5101131fd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#bb93b5dbfb9a7f7d64365340d5516e73">IsConnectionAttemptPending</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ca0cb46f8b48b2f2d5da83377c918064">IsConnected</a> (const AddressOrGUID systemIdentifier, bool includeInProgress=false, bool includeDisconnecting=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if a particular systemAddress is connected to us.  <a href="#ca0cb46f8b48b2f2d5da83377c918064"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d3cd736fca1b11b8e652f630f9045c06">GetIndexFromSystemAddress</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given <em>systemAddress</em>, returns its index into remoteSystemList.  <a href="#d3cd736fca1b11b8e652f630f9045c06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#1645d13c35dd97674b445dcb4b3756aa">GetSystemAddressFromIndex</a> (int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given <em>index</em> into remoteSystemList, will return a <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a>. This function is only useful for looping through all systems.  <a href="#1645d13c35dd97674b445dcb4b3756aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structRakNetGUID.html">RakNetGUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b775f22d9d981995ca6bee08d3dc2564">GetGUIDFromIndex</a> (int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as GetSystemAddressFromIndex but returns <a class="el" href="structRakNetGUID.html">RakNetGUID</a>.  <a href="#b775f22d9d981995ca6bee08d3dc2564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b52398c6543789fa3b5aa9e6c19a0fba">GetSystemList</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structSystemAddress.html">SystemAddress</a> &gt; &amp;addresses, <a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNetGUID.html">RakNetGUID</a> &gt; &amp;guids)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as calling GetSystemAddressFromIndex and GetGUIDFromIndex for all systems, but more efficient Indices match each other, so <em>addresses</em>[0] and <em>guids</em>[0] refer to the same system.  <a href="#b52398c6543789fa3b5aa9e6c19a0fba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8f641435cc9a86c48ad5f105ed4e74ed">AddToBanList</a> (const char *IP, RakNetTime milliseconds=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bans an IP from connecting.  <a href="#8f641435cc9a86c48ad5f105ed4e74ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d046c7809b8889ba708bc20881845e4d"></a><!-- doxytag: member="RakPeer::RemoveFromBanList" ref="d046c7809b8889ba708bc20881845e4d" args="(const char *IP)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d046c7809b8889ba708bc20881845e4d">RemoveFromBanList</a> (const char *IP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows a previously banned IP to connect. param[in] Dotted IP address. You can use * as a wildcard. An IP such as 128.0.0.* will ban all IP addresses starting with 128.0.0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3d0f94bb0bf24d4bbe1df80b1f3bce9d"></a><!-- doxytag: member="RakPeer::ClearBanList" ref="3d0f94bb0bf24d4bbe1df80b1f3bce9d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3d0f94bb0bf24d4bbe1df80b1f3bce9d">ClearBanList</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows all previously banned IPs to connect. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e1ad09ea9ca5ea8bd4a00f78e22a5abc">IsBanned</a> (const char *IP)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true or false indicating if a particular IP is banned.  <a href="#e1ad09ea9ca5ea8bd4a00f78e22a5abc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7aa96b5a724a9cfb9b4c53e84ccdce04">SetLimitIPConnectionFrequency</a> (bool b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable allowing frequent connections from the same IP adderss.  <a href="#7aa96b5a724a9cfb9b4c53e84ccdce04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#171a26ffc686c3666b169e8972d8e282">Ping</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3e1cda7f2e6b523902b6db6c88ca4e38">Ping</a> (const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections, unsigned connectionSocketIndex=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a ping to the specified unconnected system.  <a href="#3e1cda7f2e6b523902b6db6c88ca4e38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d49c1931b10fdc0ba3ae73305b9fd5c4">GetAveragePing</a> (const AddressOrGUID systemIdentifier)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the average of all ping times read for the specific system or -1 if none read yet.  <a href="#d49c1931b10fdc0ba3ae73305b9fd5c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ccd128e02e2b699f286d23ec3c7b0d67">GetLastPing</a> (const AddressOrGUID systemIdentifier) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the last ping time read for the specific system or -1 if none read yet.  <a href="#ccd128e02e2b699f286d23ec3c7b0d67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#cd7b8388fccf81c93fa96a48aac9283a">GetLowestPing</a> (const AddressOrGUID systemIdentifier) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the lowest ping time read or -1 if none read yet.  <a href="#cd7b8388fccf81c93fa96a48aac9283a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8324e15260b26b92abb204ed9f04ff57">SetOccasionalPing</a> (bool doPing)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7d7601d2d7114c454829c655dc9e79c7">SetOfflinePingResponse</a> (const char *data, const unsigned int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the data to send along with a LAN server discovery or offline ping reply.  <a href="#7d7601d2d7114c454829c655dc9e79c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#185506c10394d76dfe9bbc8b7dfd7613">GetOfflinePingResponse</a> (char **data, unsigned int *length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns pointers to a copy of the <em>data</em> passed to SetOfflinePingResponse.  <a href="#185506c10394d76dfe9bbc8b7dfd7613"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3bd1460173bdc15fcca80d75ba2e9305">GetInternalID</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress=UNASSIGNED_SYSTEM_ADDRESS, const int index=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the unique address identifier that represents you or another system on the the network and is based on your local IP / port.  <a href="#3bd1460173bdc15fcca80d75ba2e9305"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5379dcb1bad21a633b9c52b165a1ef59">GetExternalID</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the unique address identifier that represents the target on the the network and is based on the target's external IP / port.  <a href="#5379dcb1bad21a633b9c52b165a1ef59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structRakNetGUID.html">RakNetGUID</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#1b01ce06741a582c9e9599966dd55733">GetGuidFromSystemAddress</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> input) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a connected system address, this method gives the unique GUID representing that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>. This will be the same on all systems connected to that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Complexity is O(log2(n)). If <em>input</em> is UNASSIGNED_SYSTEM_ADDRESS, will return your own GUID.  <a href="#1b01ce06741a582c9e9599966dd55733"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7b99f10bb48b76fcef310226c277870a">GetSystemAddressFromGuid</a> (const <a class="el" href="structRakNetGUID.html">RakNetGUID</a> input) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gives the system address of a connected system, given its GUID. The GUID will be the same on all systems connected to that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Currently O(log(n)), but this may be improved in the future If <em>input</em> is UNASSIGNED_RAKNET_GUID, UNASSIGNED_SYSTEM_ADDRESS is returned.  <a href="#7b99f10bb48b76fcef310226c277870a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e07b0a50700a8c79d9c04360acf9945e">SetTimeoutTime</a> (RakNetTime timeMS, const <a class="el" href="structSystemAddress.html">SystemAddress</a> target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message.  <a href="#e07b0a50700a8c79d9c04360acf9945e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f6bcc65b6a7c937d1e87e9660252a3be">GetTimeoutTime</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the Timeout time for the given system.  <a href="#f6bcc65b6a7c937d1e87e9660252a3be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#4272ca10738749fcc2a1e3b31e048a70">GetMTUSize</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current MTU size.  <a href="#4272ca10738749fcc2a1e3b31e048a70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f8fb0787a7ac8e5e633a25da2763ca46">GetNumberOfAddresses</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of IP addresses this system has internally.  <a href="#f8fb0787a7ac8e5e633a25da2763ca46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ac2a0b2392d0a1eb3ca08f11a180dbc2">GetLocalIP</a> (unsigned int index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#251f0972c417a8770548a354a10178f5">IsLocalIP</a> (const char *ip)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#6073a5dffd55cbd7dbfc6e575c34ffc4">AllowConnectionResponseIPMigration</a> (bool allow)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allow or disallow connection responses from any IP.  <a href="#6073a5dffd55cbd7dbfc6e575c34ffc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#1337a0f14282659e56aca9c8b7d948bc">AdvertiseSystem</a> (const char *host, unsigned short remotePort, const char *data, int dataLength, unsigned connectionSocketIndex=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will send our external IP outside the LAN along with some user data to the remote system.  <a href="#1337a0f14282659e56aca9c8b7d948bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c1cb3f6aeaa842c721bbe4a3d74c3d5d">SetSplitMessageProgressInterval</a> (int interval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.  <a href="#c1cb3f6aeaa842c721bbe4a3d74c3d5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#5943788eec6c727a5b54ba20bac5a0e9">GetSplitMessageProgressInterval</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns what was passed to <a class="el" href="classRakPeer.html#c1cb3f6aeaa842c721bbe4a3d74c3d5d" title="Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.">SetSplitMessageProgressInterval()</a>.  <a href="#5943788eec6c727a5b54ba20bac5a0e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#699049419ad22610064ef595cde4560e">SetUnreliableTimeout</a> (RakNetTime timeoutMS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set how long to wait before giving up on sending an unreliable message. Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0.  <a href="#699049419ad22610064ef595cde4560e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#babf4af38512fb961f29cfc284dfeb22">SendTTL</a> (const char *host, unsigned short remotePort, int ttl, unsigned connectionSocketIndex=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message to a host, with the IP socket option TTL set to 3.  <a href="#babf4af38512fb961f29cfc284dfeb22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e20dde8c8397a680c70bdc9f6639ca58">SetCompileFrequencyTable</a> (bool doCompile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables frequency table tracking.  <a href="#e20dde8c8397a680c70bdc9f6639ca58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8b3d828002aa9946b2556f657e33f0d8">GetOutgoingFrequencyTable</a> (unsigned int outputFrequencyTable[256])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the frequency of outgoing bytes into outputFrequencyTable The purpose is to save to file as either a master frequency table from a sample game session for passing to <a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9" title="This is an optional function to generate the compression layer based on the input...">GenerateCompressionLayer()</a>.  <a href="#8b3d828002aa9946b2556f657e33f0d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9">GenerateCompressionLayer</a> (unsigned int inputFrequencyTable[256], bool inputLayer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is an optional function to generate the compression layer based on the input frequency table.  <a href="#f3b47a3087903697acac977e3525b8d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c030c867c8e685d11d0789417fdf6aaa">DeleteCompressionLayer</a> (bool inputLayer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the output or input layer as specified.  <a href="#c030c867c8e685d11d0789417fdf6aaa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b8d51c7aa3bd6662b8ee3fbd618f4c11">GetCompressionRatio</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the compression ratio.  <a href="#b8d51c7aa3bd6662b8ee3fbd618f4c11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3469f4f4b4c38bf749cb394b466b823b">GetDecompressionRatio</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the decompression ratio.  <a href="#3469f4f4b4c38bf749cb394b466b823b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b5c9a18b31e1ef50434f289b6cca9b68">AttachPlugin</a> (<a class="el" href="classPluginInterface2.html">PluginInterface2</a> *plugin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attatches a Plugin interface to an instance of the base class (<a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call.  <a href="#b5c9a18b31e1ef50434f289b6cca9b68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3af7b16093477032f5739c05316463bd">DetachPlugin</a> (<a class="el" href="classPluginInterface2.html">PluginInterface2</a> *messageHandler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to.  <a href="#3af7b16093477032f5739c05316463bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#9968ebdb31bcc7563b035a567046169b">PushBackPacket</a> (<a class="el" href="structPacket.html">Packet</a> *packet, bool pushAtHead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a message back in the receive queue in case you don't want to deal with it immediately.  <a href="#9968ebdb31bcc7563b035a567046169b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#3a007c320065e2e390bdfe91a54bdfb3">SetRouterInterface</a> (<a class="el" href="classRouterInterface.html">RouterInterface</a> *routerInterface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">------------------------------------------- Deprecated -------------------------  <a href="#3a007c320065e2e390bdfe91a54bdfb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c5c75a11b9732b1061155b730509cb6a">RemoveRouterInterface</a> (<a class="el" href="classRouterInterface.html">RouterInterface</a> *routerInterface)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2e9fba1ec7a65de313fb101f3cffd3b0">AllocatePacket</a> (unsigned dataSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a packet for you to write to if you want to create a <a class="el" href="structPacket.html" title="This represents a user message from another system.">Packet</a> for some reason. You can add it to the receive buffer with PushBackPacket.  <a href="#2e9fba1ec7a65de313fb101f3cffd3b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual RakNetSmartPtr<br class="typebreak">
&lt; RakNetSocket &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#858fbbc252b87dfe8f8e8e5f0d83bbf9">GetSocket</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the socket used with a particular active connection. The smart pointer reference counts the RakNetSocket object, so the socket will remain active as long as the smart pointer does, even if <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> were to shutdown or close the connection.  <a href="#858fbbc252b87dfe8f8e8e5f0d83bbf9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#77173ab0e5cba80dc721dc0ab12c01cd">GetSockets</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;sockets)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets all sockets in use.  <a href="#77173ab0e5cba80dc721dc0ab12c01cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#62cbbeb26969bf86d168e05a1643ad47">SetUserUpdateThread</a> (void(*_userUpdateThreadPtr)(<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *, void *), void *_userUpdateThreadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#02407ae593277c551cea1524816c3a56">ApplyNetworkSimulator</a> (float packetloss, unsigned short minExtraPing, unsigned short extraPingVariance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds simulated ping and packet loss to the outgoing data flow.  <a href="#02407ae593277c551cea1524816c3a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#43eacd3c80d27df603fe9be59174359b">SetPerConnectionOutgoingBandwidthLimit</a> (unsigned maxBitsPerSecond)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Limits how much outgoing bandwidth can be used per-connection. This limit does not apply to the sum of all connections! Exceeding the limit queues up outgoing traffic.  <a href="#43eacd3c80d27df603fe9be59174359b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#972f872d20bb187a0bbb92f29d4ae34f">IsNetworkSimulatorActive</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structRakNetStatistics.html">RakNetStatistics</a> *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#dbc8b8fdd04dadaa70e031a2f58173be">GetStatistics</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, <a class="el" href="structRakNetStatistics.html">RakNetStatistics</a> *rns=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="RakNetStatistics_8h.html#5da4aa8724a029fe037aed2631e23b78">StatisticsToString()</a> function.  <a href="#dbc8b8fdd04dadaa70e031a2f58173be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#cadf76822078525c95a6b5359ade892e">GetStatistics</a> (const int index, <a class="el" href="structRakNetStatistics.html">RakNetStatistics</a> *rns)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the network statistics of the system at the given index in the remoteSystemList.  <a href="#cadf76822078525c95a6b5359ade892e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6110dab280bb90fd0d90f5cbc8ffd886"></a><!-- doxytag: member="RakPeer::GetReceiveBufferSize" ref="6110dab280bb90fd0d90f5cbc8ffd886" args="(void)" -->
virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#6110dab280bb90fd0d90f5cbc8ffd886">GetReceiveBufferSize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">how many messages are waiting when you call <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b64dd144fe2eff743faa3e09d4a5174c">GetRemoteSystemFromSystemAddress</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool calledFromNetworkThread, bool onlyActive) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e29ffd34c6b9b3017a26096e72d5f29e"></a><!-- doxytag: member="RakPeer::ParseConnectionRequestPacket" ref="e29ffd34c6b9b3017a26096e72d5f29e" args="(RakPeer::RemoteSystemStruct *remoteSystem, SystemAddress systemAddress, const char *data, int byteSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#e29ffd34c6b9b3017a26096e72d5f29e">ParseConnectionRequestPacket</a> (RakPeer::RemoteSystemStruct *remoteSystem, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, const char *data, int byteSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse out a connection request packet. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2a6640b952f88f2a2568cfd0ef9e484a"></a><!-- doxytag: member="RakPeer::OnConnectionRequest" ref="2a6640b952f88f2a2568cfd0ef9e484a" args="(RakPeer::RemoteSystemStruct *remoteSystem, unsigned char *AESKey, bool setAESKey, RakNetTime incomingTimestamp)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#2a6640b952f88f2a2568cfd0ef9e484a">OnConnectionRequest</a> (RakPeer::RemoteSystemStruct *remoteSystem, unsigned char *AESKey, bool setAESKey, RakNetTime incomingTimestamp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When we get a connection request from an ip / port, accept it unless full. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="34ef012d4c7fdae387cff33ef3f8a82c"></a><!-- doxytag: member="RakPeer::NotifyAndFlagForShutdown" ref="34ef012d4c7fdae387cff33ef3f8a82c" args="(const SystemAddress systemAddress, bool performImmediate, unsigned char orderingChannel, PacketPriority disconnectionNotificationPriority)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#34ef012d4c7fdae387cff33ef3f8a82c">NotifyAndFlagForShutdown</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool performImmediate, unsigned char orderingChannel, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a reliable disconnect packet to this player and disconnect them when it is delivered. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01b7ddd20ebdcc83fe272da5670e1394"></a><!-- doxytag: member="RakPeer::GetNumberOfRemoteInitiatedConnections" ref="01b7ddd20ebdcc83fe272da5670e1394" args="(void) const " -->
unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#01b7ddd20ebdcc83fe272da5670e1394">GetNumberOfRemoteInitiatedConnections</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns how many remote systems initiated a connection to us. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c93e05247b42ccab6a53e271ffb71344">AssignSystemAddressToRemoteSystemList</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, RemoteSystemStruct::ConnectMode connectionMode, RakNetSmartPtr&lt; RakNetSocket &gt; incomingRakNetSocket, bool *thisIPConnectedRecently, <a class="el" href="structSystemAddress.html">SystemAddress</a> bindingAddress, int incomingMTU, <a class="el" href="structRakNetGUID.html">RakNetGUID</a> guid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a free remote system from the list and assign our systemAddress to it.  <a href="#c93e05247b42ccab6a53e271ffb71344"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#303003eed8c97558f6c9b2657f76a7ae">ShiftIncomingTimestamp</a> (unsigned char *data, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adjust the timestamp of the incoming packet to be relative to this system.  <a href="#303003eed8c97558f6c9b2657f76a7ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c4aff573e1973d4a12c42090b23c0d41">GetBestClockDifferential</a> (const <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#b28534e0a89741d3b98b9e08a55c62b3">HandleRPCPacket</a> (const char *data, int length, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles an RPC packet. This packet has an RPC request.  <a href="#b28534e0a89741d3b98b9e08a55c62b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#f181aebf9663297b633a7f0f7afbd74e">HandleRPCReplyPacket</a> (const char *data, int length, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handles an RPC reply packet. The reply packet has data returned from an RPC call.  <a href="#f181aebf9663297b633a7f0f7afbd74e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7cfe43a66680f16050b43df0118a0f00"></a><!-- doxytag: member="RakPeer::endThreads" ref="7cfe43a66680f16050b43df0118a0f00" args="" -->
volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#7cfe43a66680f16050b43df0118a0f00">endThreads</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this to true to terminate the Peer thread execution. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55544eb11720fe938193c6b79bc65d18"></a><!-- doxytag: member="RakPeer::isMainLoopThreadActive" ref="55544eb11720fe938193c6b79bc65d18" args="" -->
volatile bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#55544eb11720fe938193c6b79bc65d18">isMainLoopThreadActive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true if the peer thread is active. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">*unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#af0f4145d68e3aab994aa58dabd8047e">maximumNumberOfPeers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the maximum number of peers allowed to connect.  <a href="#af0f4145d68e3aab994aa58dabd8047e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8ac75ac0847890a84a490143e7499dd8">maximumIncomingConnections</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Store the maximum number of peers able to connect, including reserved connection slots for pings, etc.  <a href="#8ac75ac0847890a84a490143e7499dd8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c1756b0cf7cd10253e65a23b126b5ba2"></a><!-- doxytag: member="RakPeer::mySystemAddress" ref="c1756b0cf7cd10253e65a23b126b5ba2" args="[MAXIMUM_NUMBER_OF_INTERNAL_IDS]" -->
<a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#c1756b0cf7cd10253e65a23b126b5ba2">mySystemAddress</a> [MAXIMUM_NUMBER_OF_INTERNAL_IDS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Local Player ID. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteSystemStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#fac48c9f0bb054679a435ea8eb309181">remoteSystemList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="886adb8f6d621863a031f7eee9ce3041"></a><!-- doxytag: member="RakPeer::updateCycleIsRunning" ref="886adb8f6d621863a031f7eee9ce3041" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#886adb8f6d621863a031f7eee9ce3041">updateCycleIsRunning</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RunUpdateCycle is not thread safe but we don't need to mutex calls. Just skip calls if it is running already. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#ba1ca9377af6817e35620c47bc89887f">bytesSentPerSecond</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The list of people we have tried to connect to recently.  <a href="#ba1ca9377af6817e35620c47bc89887f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="addf5f5e8397c893518952c2421b1709"></a><!-- doxytag: member="RakPeer::frequencyTable" ref="addf5f5e8397c893518952c2421b1709" args="[256]" -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#addf5f5e8397c893518952c2421b1709">frequencyTable</a> [256]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compression stuff. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d09e4ac8d31b115425d20bd01993567a"></a><!-- doxytag: member="RakPeer::rsacrypt" ref="d09e4ac8d31b115425d20bd01993567a" args="" -->
RSACrypt&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#d09e4ac8d31b115425d20bd01993567a">rsacrypt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encryption and security. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#8dc645e7f22a90abe45dfc3fdc74044f">allowConnectionResponseIPMigration</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How long it has been since things were updated by a call to receiveUpdate thread uses this to determine how long to sleep for.  <a href="#8dc645e7f22a90abe45dfc3fdc74044f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classSimpleMutex.html">SimpleMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakPeer.html#576b14709afe3ab4084b0bba460d6cb7">sendReceiptSerialMutex</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main interface for network communications. 
<p>
It implements most of RakNet's functionality and is the primary interface for <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a>.<p>
Inherits <a class="el" href="classRakPeerInterface.html" title="The main interface for network communications.">RakPeerInterface</a>.<p>
See the individual functions for what the class can do. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8f641435cc9a86c48ad5f105ed4e74ed"></a><!-- doxytag: member="RakPeer::AddToBanList" ref="8f641435cc9a86c48ad5f105ed4e74ed" args="(const char *IP, RakNetTime milliseconds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::AddToBanList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bans an IP from connecting. 
<p>
Banned IPs persist between connections but are not saved on shutdown nor loaded on startup. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>Dotted IP address. You can use * for a wildcard address, such as 128.0.0. * will ban all IP addresses starting with 128.0.0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>milliseconds</em>&nbsp;</td><td>Gives time in milli seconds for a temporary ban of the IP address. Use 0 for a permanent ban. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#2bd5066568cb0ceffd622bc83a674d9c">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="f8d5bea4ceaa700d451196b9b0b0ed25"></a><!-- doxytag: member="RakPeer::AddToSecurityExceptionList" ref="f8d5bea4ceaa700d451196b9b0b0ed25" args="(const char *ip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::AddToSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is useful if you have a fixed-address internal server behind a LAN. 
<p>
Secure connections are determined by the recipient of an incoming connection. This has no effect if called on the system attempting to connect. <dl class="note" compact><dt><b>Note:</b></dt><dd>If secure connections are on, do not use secure connections for a specific IP address. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ip</em>&nbsp;</td><td>IP address to add. * wildcards are supported. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#7b262b1da3f8837939330735ae00aaef">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="1337a0f14282659e56aca9c8b7d948bc"></a><!-- doxytag: member="RakPeer::AdvertiseSystem" ref="1337a0f14282659e56aca9c8b7d948bc" args="(const char *host, unsigned short remotePort, const char *data, int dataLength, unsigned connectionSocketIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::AdvertiseSystem           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will send our external IP outside the LAN along with some user data to the remote system. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Optional data to append to the packet. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataLength</em>&nbsp;</td><td>Length of data in bytes. Use 0 if no data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False if <a class="el" href="classRakPeer.html#52ff3b23878d11d8b00473835d44b1f5" title="Returns true if the network thread is running.">IsActive()</a>==false or the host is unresolvable. True otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#f814ceeb3f54841c9919d2af8d86e988">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="2e9fba1ec7a65de313fb101f3cffd3b0"></a><!-- doxytag: member="RakPeer::AllocatePacket" ref="2e9fba1ec7a65de313fb101f3cffd3b0" args="(unsigned dataSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPacket.html">Packet</a>* RakPeer::AllocatePacket           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dataSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a packet for you to write to if you want to create a <a class="el" href="structPacket.html" title="This represents a user message from another system.">Packet</a> for some reason. You can add it to the receive buffer with PushBackPacket. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataSize</em>&nbsp;</td><td>How many bytes to allocate for the buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A packet. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#aee2b90c9adf3a359ba5f2c3d8c38793">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="6073a5dffd55cbd7dbfc6e575c34ffc4"></a><!-- doxytag: member="RakPeer::AllowConnectionResponseIPMigration" ref="6073a5dffd55cbd7dbfc6e575c34ffc4" args="(bool allow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::AllowConnectionResponseIPMigration           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow or disallow connection responses from any IP. 
<p>
Normally this should be false, but may be necessary when connecting to servers with multiple IP addresses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow</em>&nbsp;</td><td>- True to allow this behavior, false to not allow. Defaults to false. Value persists between connections. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#6d6f317bc7bc9ff3dfc3b3044df7242f">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="02407ae593277c551cea1524816c3a56"></a><!-- doxytag: member="RakPeer::ApplyNetworkSimulator" ref="02407ae593277c551cea1524816c3a56" args="(float packetloss, unsigned short minExtraPing, unsigned short extraPingVariance)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::ApplyNetworkSimulator           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>packetloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>minExtraPing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>extraPingVariance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds simulated ping and packet loss to the outgoing data flow. 
<p>
To simulate bi-directional ping and packet loss, you should call this on both the sender and the recipient, with half the total ping and maxSendBPS values on each. <dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>Use <a href="http://www.jenkinssoftware.com/raknet/forum/index.php?topic=1671.0">http://www.jenkinssoftware.com/raknet/forum/index.php?topic=1671.0</a> instead. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>You can exclude network simulator code with the define _RELEASE to decrease code size. <p>
Doesn't work past version 3.6201 </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packetloss</em>&nbsp;</td><td>Chance to lose a packet. Ranges from 0 to 1. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minExtraPing</em>&nbsp;</td><td>The minimum time to delay sends. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>extraPingVariance</em>&nbsp;</td><td>The additional random time to delay sends. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#ed1fd1a31d740525d14ac855c0ff2997">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c93e05247b42ccab6a53e271ffb71344"></a><!-- doxytag: member="RakPeer::AssignSystemAddressToRemoteSystemList" ref="c93e05247b42ccab6a53e271ffb71344" args="(const SystemAddress systemAddress, RemoteSystemStruct::ConnectMode connectionMode, RakNetSmartPtr&lt; RakNetSocket &gt; incomingRakNetSocket, bool *thisIPConnectedRecently, SystemAddress bindingAddress, int incomingMTU, RakNetGUID guid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* RakPeer::AssignSystemAddressToRemoteSystemList           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoteSystemStruct::ConnectMode&nbsp;</td>
          <td class="paramname"> <em>connectionMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetSmartPtr&lt; RakNetSocket &gt;&nbsp;</td>
          <td class="paramname"> <em>incomingRakNetSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>thisIPConnectedRecently</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>bindingAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>incomingMTU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNetGUID.html">RakNetGUID</a>&nbsp;</td>
          <td class="paramname"> <em>guid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a free remote system from the list and assign our systemAddress to it. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Should only be called from the update thread - not the user thread. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>systemAddress to be assigned </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionMode</em>&nbsp;</td><td>connection mode of the RemoteSystem. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rakNetSocket</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>thisIPConnectedRecently</em>&nbsp;</td><td>Is this IP connected recently? set to False; </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bindingAddress</em>&nbsp;</td><td>Address to be binded with the remote system </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>incomingMTU</em>&nbsp;</td><td>MTU for the remote system </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5c9a18b31e1ef50434f289b6cca9b68"></a><!-- doxytag: member="RakPeer::AttachPlugin" ref="b5c9a18b31e1ef50434f289b6cca9b68" args="(PluginInterface2 *plugin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::AttachPlugin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPluginInterface2.html">PluginInterface2</a> *&nbsp;</td>
          <td class="paramname"> <em>plugin</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attatches a Plugin interface to an instance of the base class (<a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If plugins have dependencies on each other then the order does matter - for example the router plugin should go first because it might route messages for other plugins. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to the plugin to attach. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#d8a57fb05316a8d3ac16a9c424131a5c">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="01b140bb9e6a90a0c1867a5101131fd1"></a><!-- doxytag: member="RakPeer::CancelConnectionAttempt" ref="01b140bb9e6a90a0c1867a5101131fd1" args="(const SystemAddress target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::CancelConnectionAttempt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a pending connection attempt. 
<p>
If we are already connected, the connection stays open <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Target system to cancel. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#4b07ddc89a81c710dda386d8914bd12a">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="4a7c586a8be0d977354a3cfd09bab6b7"></a><!-- doxytag: member="RakPeer::CloseConnection" ref="4a7c586a8be0d977354a3cfd09bab6b7" args="(const SystemAddress target, bool sendDisconnectionNotification, unsigned char orderingChannel=0, PacketPriority disconnectionNotificationPriority=LOW_PRIORITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::CloseConnection           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendDisconnectionNotification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>disconnectionNotificationPriority</em> = <code>LOW_PRIORITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out). 
<p>
This method closes the connection irrespective of who initiated the connection. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to close the connection to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendDisconnectionNotification</em>&nbsp;</td><td>True to send ID_DISCONNECTION_NOTIFICATION to the recipient. False to close it silently. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Which ordering channel to send the disconnection notification on, if any </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>disconnectionNotificationPriority</em>&nbsp;</td><td>Priority to send ID_DISCONNECTION_NOTIFICATION on. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#46d50d2581077e4856f7dc841197dd19">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c7ba51ef72df78a7da4b7e6d5e2c8276"></a><!-- doxytag: member="RakPeer::Connect" ref="c7ba51ef72df78a7da4b7e6d5e2c8276" args="(const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNetTime timeoutTime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::Connect           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sendConnectionAttemptCount</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>timeBetweenSendConnectionAttemptsMS</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timeoutTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the specified host (ip or domain name) and server port. 
<p>
Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer.<p>
This is a non-blocking connection.<p>
The connection is successful when <a class="el" href="classRakPeer.html#ca0cb46f8b48b2f2d5da83377c918064" title="Returns if a particular systemAddress is connected to us.">IsConnected()</a> returns true or <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> gets a message with the type identifier ID_CONNECTION_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Requires that you first call Initialize. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to <a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c" title="Sets the password for the incoming connections.">SetIncomingPassword()</a>. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to determine the one to send on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendConnectionAttemptCount</em>&nbsp;</td><td>Number of datagrams to send to the other system to try to connect. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeBetweenSendConnectionAttemptsMS</em>&nbsp;</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutTime</em>&nbsp;</td><td>Time to elapse before dropping the connection if a reliable message could not be sent. 0 to use the default value from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful initiation. False if you are already connected to this system, a connection to the system is pending, the domain name cannot be resolved, incorrect parameters, internal error, or too many existing peers. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Returning true does not mean you are connected! TODO - <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> 4 - return enum </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#8d7ac1a40bbaa75455fb262d80b311a8">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3341478f794ee257e957021834a41b71"></a><!-- doxytag: member="RakPeer::ConnectWithSocket" ref="3341478f794ee257e957021834a41b71" args="(const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, RakNetSmartPtr&lt; RakNetSocket &gt; socket, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNetTime timeoutTime=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakPeer::ConnectWithSocket           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetSmartPtr&lt; RakNetSocket &gt;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sendConnectionAttemptCount</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>timeBetweenSendConnectionAttemptsMS</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timeoutTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the specified host (ip or domain name) and server port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to <a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c" title="Sets the password for the incoming connections.">SetIncomingPassword()</a>. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socket</em>&nbsp;</td><td>A bound socket returned by another instance of <a class="el" href="classRakPeerInterface.html" title="The main interface for network communications.">RakPeerInterface</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendConnectionAttemptCount</em>&nbsp;</td><td>Number of datagrams to send to the other system to try to connect. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeBetweenSendConnectionAttemptsMS</em>&nbsp;</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutTime</em>&nbsp;</td><td>Time to elapse before dropping the connection if a reliable message could not be sent. 0 to use the default from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on successful initiation. False on incorrect parameters, internal error, or too many existing peers. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Returning true does not mean you arebconnected! </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#578f8ed36fc9ade5e52601c24a1bbafe">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="f68f8d2766b45b6d951dfd62cf349a71"></a><!-- doxytag: member="RakPeer::DeallocatePacket" ref="f68f8d2766b45b6d951dfd62cf349a71" args="(Packet *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::DeallocatePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this to deallocate a message returned by <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> when you are done handling it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>Message to deallocate. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#8e792f3d13652387fcf12542bc1cd2be">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c030c867c8e685d11d0789417fdf6aaa"></a><!-- doxytag: member="RakPeer::DeleteCompressionLayer" ref="c030c867c8e685d11d0789417fdf6aaa" args="(bool inputLayer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::DeleteCompressionLayer           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inputLayer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete the output or input layer as specified. 
<p>
This is not necessary to call and is only useful for freeing memory. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputLayer</em>&nbsp;</td><td>True to mean the inputLayer, false to mean the output layer. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False (failure) if connected. Otherwise True (success). </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#5ae0c3a39a6d29458d12094988a67f40">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3af7b16093477032f5739c05316463bd"></a><!-- doxytag: member="RakPeer::DetachPlugin" ref="3af7b16093477032f5739c05316463bd" args="(PluginInterface2 *messageHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::DetachPlugin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPluginInterface2.html">PluginInterface2</a> *&nbsp;</td>
          <td class="paramname"> <em>messageHandler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to. 
<p>
This method disables the plugin code from running automatically on base class's updates or message receipt. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to a plugin to detach. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#c267d66df8d2f8e10394cf228581f8d0">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="bc9e3cd4ac407f23ce1ee99c94cabd88"></a><!-- doxytag: member="RakPeer::DisableSecurity" ref="bc9e3cd4ac407f23ce1ee99c94cabd88" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::DisableSecurity           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables all security. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Must be called while offline. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#06966ce41b033b7c8a7e460333968c3b">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="f3b47a3087903697acac977e3525b8d9"></a><!-- doxytag: member="RakPeer::GenerateCompressionLayer" ref="f3b47a3087903697acac977e3525b8d9" args="(unsigned int inputFrequencyTable[256], bool inputLayer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::GenerateCompressionLayer           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>inputFrequencyTable</em>[256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>inputLayer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an optional function to generate the compression layer based on the input frequency table. 
<p>
If you want to use it you should call this twice - once with inputLayer as true and once as false. The frequency table passed here with inputLayer=true should match the frequency table on the recipient with inputLayer=false. Likewise, the frequency table passed here with inputLayer=false should match the frequency table on the recipient with inputLayer=true. Calling this function when there is an existing layer will overwrite the old layer. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputFrequencyTable</em>&nbsp;</td><td>A frequency table for your data returned from <a class="el" href="classRakPeer.html#8b3d828002aa9946b2556f657e33f0d8" title="Returns the frequency of outgoing bytes into outputFrequencyTable The purpose is...">GetOutgoingFrequencyTable()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputLayer</em>&nbsp;</td><td>Whether inputFrequencyTable represents incoming data from other systems (true) or outgoing data from this system (false). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false (failure) if connected. Otherwise true (success) </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Compression.cpp </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#db8ccf96299cc5cb92728b2cc98f9cb6">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="d49c1931b10fdc0ba3ae73305b9fd5c4"></a><!-- doxytag: member="RakPeer::GetAveragePing" ref="d49c1931b10fdc0ba3ae73305b9fd5c4" args="(const AddressOrGUID systemIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetAveragePing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the average of all ping times read for the specific system or -1 if none read yet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ping time for this system, or -1 </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#7b5f44732042e520afe3393b50c1bf16">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c4aff573e1973d4a12c42090b23c0d41"></a><!-- doxytag: member="RakPeer::GetBestClockDifferential" ref="c4aff573e1973d4a12c42090b23c0d41" args="(const SystemAddress systemAddress) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNetTime RakPeer::GetBestClockDifferential           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the most accurate clock differential for a certain player. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The player with whose clock the time difference is calculated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The clock differential for a certain player. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8d51c7aa3bd6662b8ee3fbd618f4c11"></a><!-- doxytag: member="RakPeer::GetCompressionRatio" ref="b8d51c7aa3bd6662b8ee3fbd618f4c11" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RakPeer::GetCompressionRatio           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the compression ratio. 
<p>
A low compression ratio is good. Compression is defined for outgoing data. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The compression ratio </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#12249f11335df1ae09e2b560e9b5d0f2">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f3e89dc1baf72e449911b7c674403fc"></a><!-- doxytag: member="RakPeer::GetConnectionList" ref="2f3e89dc1baf72e449911b7c674403fc" args="(SystemAddress *remoteSystems, unsigned short *numberOfSystems) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::GetConnectionList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>remoteSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>numberOfSystems</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the array remoteSystems with the <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> of all the systems we are connected to. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>remoteSystems</em>&nbsp;</td><td>An array of <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> structures, to be filled with the SystemAddresss of the systems we are connected to. Pass 0 to remoteSystems to get the number of systems we are connected to. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numberOfSystems</em>&nbsp;</td><td>As input, the size of remoteSystems array. As output, the number of elements put into the array. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#190feb3608caded7772f4bea292e15f9">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3469f4f4b4c38bf749cb394b466b823b"></a><!-- doxytag: member="RakPeer::GetDecompressionRatio" ref="3469f4f4b4c38bf749cb394b466b823b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float RakPeer::GetDecompressionRatio           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the decompression ratio. 
<p>
A high decompression ratio is good. Decompression ratio is defined for incoming data. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The decompression ratio </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#89e447614d28c58e0bf3cbed5f36b734">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="5379dcb1bad21a633b9c52b165a1ef59"></a><!-- doxytag: member="RakPeer::GetExternalID" ref="5379dcb1bad21a633b9c52b165a1ef59" args="(const SystemAddress target) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> RakPeer::GetExternalID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the unique address identifier that represents the target on the the network and is based on the target's external IP / port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>The <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> of the remote system. Usually the same for all systems, unless you have two or more network cards. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#a270ba54dd5e3383f1bdd236165bdfb0">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="b775f22d9d981995ca6bee08d3dc2564"></a><!-- doxytag: member="RakPeer::GetGUIDFromIndex" ref="b775f22d9d981995ca6bee08d3dc2564" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNetGUID.html">RakNetGUID</a> RakPeer::GetGUIDFromIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as GetSystemAddressFromIndex but returns <a class="el" href="structRakNetGUID.html">RakNetGUID</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structRakNetGUID.html">RakNetGUID</a> </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#d03b01a2cbd592dce14728e18f5d143d">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="1b01ce06741a582c9e9599966dd55733"></a><!-- doxytag: member="RakPeer::GetGuidFromSystemAddress" ref="1b01ce06741a582c9e9599966dd55733" args="(const SystemAddress input) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structRakNetGUID.html">RakNetGUID</a>&amp; RakPeer::GetGuidFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a connected system address, this method gives the unique GUID representing that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>. This will be the same on all systems connected to that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Complexity is O(log2(n)). If <em>input</em> is UNASSIGNED_SYSTEM_ADDRESS, will return your own GUID. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Call <a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85" title="Starts the network threads and opens the listen port.">Startup()</a> first, or the function will return UNASSIGNED_RAKNET_GUID </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The system address of the target system we are connected to. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#bfd7bb579f304938c258bca12891baca">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3d16efedd2007d917e613a78f816baba"></a><!-- doxytag: member="RakPeer::GetIncomingPassword" ref="3d16efedd2007d917e613a78f816baba" args="(char *passwordData, int *passwordDataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::GetIncomingPassword           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the password passed to SetIncomingPassword. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>Should point to a block large enough to hold the password data you passed to <a class="el" href="classRakPeer.html#a6daafe75bfe4882aa46f32cb753378c" title="Sets the password for the incoming connections.">SetIncomingPassword()</a> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>Maximum size of the passwordData array. Modified to hold the number of bytes actually written. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#0930dfa8ac5c2e9ec184fbed97a55a4a">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="d3cd736fca1b11b8e652f630f9045c06"></a><!-- doxytag: member="RakPeer::GetIndexFromSystemAddress" ref="d3cd736fca1b11b8e652f630f9045c06" args="(const SystemAddress systemAddress) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetIndexFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given <em>systemAddress</em>, returns its index into remoteSystemList. 
<p>
Values range from 0 to the maximum number of players allowed - 1. This includes systems which were formerly connected, but are now not connected. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of this <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> or -1 on system not found. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#a632a927cf449da8ca834b82297b1714">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3bd1460173bdc15fcca80d75ba2e9305"></a><!-- doxytag: member="RakPeer::GetInternalID" ref="3bd1460173bdc15fcca80d75ba2e9305" args="(const SystemAddress systemAddress=UNASSIGNED_SYSTEM_ADDRESS, const int index=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> RakPeer::GetInternalID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em> = <code>UNASSIGNED_SYSTEM_ADDRESS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the unique address identifier that represents you or another system on the the network and is based on your local IP / port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Use UNASSIGNED_SYSTEM_ADDRESS to get your behind-LAN address. Use a connected system to get their behind-LAN address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>When you have multiple internal IDs, which index to return? Currently limited to MAXIMUM_NUMBER_OF_INTERNAL_IDS (so the maximum value of this variable is MAXIMUM_NUMBER_OF_INTERNAL_IDS-1) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Identifier of your system internally, which may not be how other systems see if you if you are behind a NAT or proxy </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#b10bf09244843d53b1edf5e553037a99">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="ccd128e02e2b699f286d23ec3c7b0d67"></a><!-- doxytag: member="RakPeer::GetLastPing" ref="ccd128e02e2b699f286d23ec3c7b0d67" args="(const AddressOrGUID systemIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetLastPing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last ping time read for the specific system or -1 if none read yet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The last ping time for this system, or -1. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#8ea1d602ca130ed3d4d73915c6d35f44">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="ac2a0b2392d0a1eb3ca08f11a180dbc2"></a><!-- doxytag: member="RakPeer::GetLocalIP" ref="ac2a0b2392d0a1eb3ca08f11a180dbc2" args="(unsigned int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* RakPeer::GetLocalIP           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an IP address at index 0 to GetNumberOfAddresses-1 in ipList array. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>index into the list of IP addresses </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local IP address at this index </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#c06c1f57cfaf5d9aad21f5d4e419337a">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="cd7b8388fccf81c93fa96a48aac9283a"></a><!-- doxytag: member="RakPeer::GetLowestPing" ref="cd7b8388fccf81c93fa96a48aac9283a" args="(const AddressOrGUID systemIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetLowestPing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the lowest ping time read or -1 if none read yet. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The lowest ping time for this system, or -1. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#563288be08642a66729f0652ee3b1a91">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="5c413e010504007506d6be8bc27a2668"></a><!-- doxytag: member="RakPeer::GetMaximumIncomingConnections" ref="5c413e010504007506d6be8bc27a2668" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short RakPeer::GetMaximumIncomingConnections           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value passed to <a class="el" href="classRakPeer.html#d2004ca40f0a88ca24f70196321d48c8" title="Sets the maximum number of incoming connections allowed.">SetMaximumIncomingConnections()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Maximum number of incoming connections, which is always &lt;= maxConnections </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#717b4bbf42ed8f1a794158dc1e3d7a78">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="23aa5e3e7f94cccd150392ff73233526"></a><!-- doxytag: member="RakPeer::GetMaximumNumberOfPeers" ref="23aa5e3e7f94cccd150392ff73233526" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short RakPeer::GetMaximumNumberOfPeers           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the total number of connections we are allowed. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Total number of connections allowed. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#0302427800e944489b845eec5f6609d5">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="4272ca10738749fcc2a1e3b31e048a70"></a><!-- doxytag: member="RakPeer::GetMTUSize" ref="4272ca10738749fcc2a1e3b31e048a70" args="(const SystemAddress target) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetMTUSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current MTU size. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to get MTU for. UNASSIGNED_SYSTEM_ADDRESS to get the default </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current MTU size of the target system. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#63e510fcf6f0be7d4e2125e5e93c7391">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="9c056f687a5be705c2d54ef2ca311243"></a><!-- doxytag: member="RakPeer::GetNetworkIDManager" ref="9c056f687a5be705c2d54ef2ca311243" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a>* RakPeer::GetNetworkIDManager           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the value passed to SetNetworkIDManager or 0 if never called. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#9f0b16758bb5bf43c0bd53dc1882ab61">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="826f37d914c04365cb3276e7d8598f88"></a><!-- doxytag: member="RakPeer::GetNextSendReceipt" ref="826f37d914c04365cb3276e7d8598f88" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakPeer::GetNextSendReceipt           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next uint32_t that <a class="el" href="classRakPeer.html#cf41cc0dc46e2d9678504eed199a4815" title="Sends a block of data to the specified system that you are connected to.">Send()</a> will return <dl class="note" compact><dt><b>Note:</b></dt><dd>If using <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, this may not be accurate for your thread. Use <a class="el" href="classRakPeer.html#71721eb4963b3aa7d39816d9e21438b7">IncrementNextSendReceipt()</a> in that case. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next uint32_t that <a class="el" href="classRakPeer.html#cf41cc0dc46e2d9678504eed199a4815" title="Sends a block of data to the specified system that you are connected to.">Send()</a> or SendList will return </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3841b0ec64542e4771542911d4388437">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="f8fb0787a7ac8e5e633a25da2763ca46"></a><!-- doxytag: member="RakPeer::GetNumberOfAddresses" ref="f8fb0787a7ac8e5e633a25da2763ca46" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned RakPeer::GetNumberOfAddresses           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the number of IP addresses this system has internally. 
<p>
Get the actual addresses from <a class="el" href="classRakPeer.html#ac2a0b2392d0a1eb3ca08f11a180dbc2">GetLocalIP()</a> 
<p>Implements <a class="el" href="classRakPeerInterface.html#96fd6cf3e892aad5b056bf158e6ba344">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="185506c10394d76dfe9bbc8b7dfd7613"></a><!-- doxytag: member="RakPeer::GetOfflinePingResponse" ref="185506c10394d76dfe9bbc8b7dfd7613" args="(char **data, unsigned int *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::GetOfflinePingResponse           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointers to a copy of the <em>data</em> passed to SetOfflinePingResponse. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a copy of the data passed to <a class="el" href="classRakPeer.html#7d7601d2d7114c454829c655dc9e79c7" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse()</a> </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>A pointer filled in with the length parameter passed to <a class="el" href="classRakPeer.html#7d7601d2d7114c454829c655dc9e79c7" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse()</a> </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classRakPeer.html#7d7601d2d7114c454829c655dc9e79c7" title="Sets the data to send along with a LAN server discovery or offline ping reply.">SetOfflinePingResponse</a> </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#a6a1db2cefbd3c23a6a5972e7dc36243">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="8b3d828002aa9946b2556f657e33f0d8"></a><!-- doxytag: member="RakPeer::GetOutgoingFrequencyTable" ref="8b3d828002aa9946b2556f657e33f0d8" args="(unsigned int outputFrequencyTable[256])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::GetOutgoingFrequencyTable           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>outputFrequencyTable</em>[256]          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the frequency of outgoing bytes into outputFrequencyTable The purpose is to save to file as either a master frequency table from a sample game session for passing to <a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9" title="This is an optional function to generate the compression layer based on the input...">GenerateCompressionLayer()</a>. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>You should only call this when disconnected. Requires that you first enable data frequency tracking by calling SetCompileFrequencyTable(true) </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outputFrequencyTable</em>&nbsp;</td><td>The frequency of each corresponding byte </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False (failure) if connected or if frequency table tracking is not enabled. Otherwise true (success) </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#151cb8f69faadbbca6d2d0827c767544">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="b64dd144fe2eff743faa3e09d4a5174c"></a><!-- doxytag: member="RakPeer::GetRemoteSystemFromSystemAddress" ref="b64dd144fe2eff743faa3e09d4a5174c" args="(const SystemAddress systemAddress, bool calledFromNetworkThread, bool onlyActive) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* RakPeer::GetRemoteSystemFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>calledFromNetworkThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyActive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the reliability layer associated with a systemAddress. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The player identifier </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if none </dd></dl>

</div>
</div><p>
<a class="anchor" name="858fbbc252b87dfe8f8e8e5f0d83bbf9"></a><!-- doxytag: member="RakPeer::GetSocket" ref="858fbbc252b87dfe8f8e8e5f0d83bbf9" args="(const SystemAddress target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RakNetSmartPtr&lt;RakNetSocket&gt; RakPeer::GetSocket           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the socket used with a particular active connection. The smart pointer reference counts the RakNetSocket object, so the socket will remain active as long as the smart pointer does, even if <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> were to shutdown or close the connection. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer object containing the socket information about the target. Be sure to check IsNull() which is returned if the update thread is unresponsive, shutting down, or if this system is not connected. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#4a577cdfbcec2969607ffa64d111fd03">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="77173ab0e5cba80dc721dc0ab12c01cd"></a><!-- doxytag: member="RakPeer::GetSockets" ref="77173ab0e5cba80dc721dc0ab12c01cd" args="(DataStructures::List&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;sockets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeer::GetSockets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sockets</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets all sockets in use. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sockets</em>&nbsp;</td><td>List of RakNetSocket structures in use. Sockets will not be closed until <em>sockets</em> goes out of scope </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#585a6fc79fbd3301fb19671dff7c47af">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="5943788eec6c727a5b54ba20bac5a0e9"></a><!-- doxytag: member="RakPeer::GetSplitMessageProgressInterval" ref="5943788eec6c727a5b54ba20bac5a0e9" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int RakPeer::GetSplitMessageProgressInterval           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns what was passed to <a class="el" href="classRakPeer.html#c1cb3f6aeaa842c721bbe4a3d74c3d5d" title="Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads.">SetSplitMessageProgressInterval()</a>. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of messages to be recieved before a download progress notification is returned. Default to 0. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#4466f49b544d7ba0a0f1d075fcb39b2d">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="cadf76822078525c95a6b5359ade892e"></a><!-- doxytag: member="RakPeer::GetStatistics" ref="cadf76822078525c95a6b5359ade892e" args="(const int index, RakNetStatistics *rns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::GetStatistics           </td>
          <td>(</td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNetStatistics.html">RakNetStatistics</a> *&nbsp;</td>
          <td class="paramname"> <em>rns</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the network statistics of the system at the given index in the remoteSystemList. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the index is less than the maximum number of peers allowed and the system is active. False otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="dbc8b8fdd04dadaa70e031a2f58173be"></a><!-- doxytag: member="RakPeer::GetStatistics" ref="dbc8b8fdd04dadaa70e031a2f58173be" args="(const SystemAddress systemAddress, RakNetStatistics *rns=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structRakNetStatistics.html">RakNetStatistics</a>* const RakPeer::GetStatistics           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNetStatistics.html">RakNetStatistics</a> *&nbsp;</td>
          <td class="paramname"> <em>rns</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="RakNetStatistics_8h.html#5da4aa8724a029fe037aed2631e23b78">StatisticsToString()</a> function. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which connected system to get statistics for. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rns</em>&nbsp;</td><td>If you supply this structure,the network statistics will be written to it. Otherwise the method uses a static struct to write the data, which is not threadsafe. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the specified system can't be found. Otherwise a pointer to the struct containing the specified system's network statistics. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="RakNetStatistics_8h.html" title="A structure that holds all statistical data returned by RakNet.">RakNetStatistics.h</a> </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#bbf8226d5e904df116b22ab7a3568e4f">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="7b99f10bb48b76fcef310226c277870a"></a><!-- doxytag: member="RakPeer::GetSystemAddressFromGuid" ref="7b99f10bb48b76fcef310226c277870a" args="(const RakNetGUID input) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> RakPeer::GetSystemAddressFromGuid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNetGUID.html">RakNetGUID</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gives the system address of a connected system, given its GUID. The GUID will be the same on all systems connected to that instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different. Currently O(log(n)), but this may be improved in the future If <em>input</em> is UNASSIGNED_RAKNET_GUID, UNASSIGNED_SYSTEM_ADDRESS is returned. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The <a class="el" href="structRakNetGUID.html">RakNetGUID</a> of the target system. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#98469509b8381427ef818dfd86b6a69b">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="1645d13c35dd97674b445dcb4b3756aa"></a><!-- doxytag: member="RakPeer::GetSystemAddressFromIndex" ref="1645d13c35dd97674b445dcb4b3756aa" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> RakPeer::GetSystemAddressFromIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given <em>index</em> into remoteSystemList, will return a <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a>. This function is only useful for looping through all systems. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> structure corresponding to <em>index</em> in remoteSystemList. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3541ce996094c0a4123f5dbb6742e50c">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="b52398c6543789fa3b5aa9e6c19a0fba"></a><!-- doxytag: member="RakPeer::GetSystemList" ref="b52398c6543789fa3b5aa9e6c19a0fba" args="(DataStructures::List&lt; SystemAddress &gt; &amp;addresses, DataStructures::List&lt; RakNetGUID &gt; &amp;guids)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::GetSystemList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structSystemAddress.html">SystemAddress</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNetGUID.html">RakNetGUID</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>guids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as calling GetSystemAddressFromIndex and GetGUIDFromIndex for all systems, but more efficient Indices match each other, so <em>addresses</em>[0] and <em>guids</em>[0] refer to the same system. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addresses</em>&nbsp;</td><td>All system addresses. Size of the list is the number of connections. Size of the <em>addresses</em> list will match the size of the <em>guids</em> list. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>guids</em>&nbsp;</td><td>All guids. Size of the list is the number of connections. Size of the list will match the size of the <em>addresses</em> list. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#4fb9c0d3dba316c1222ff7c8fd69f0fa">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="f6bcc65b6a7c937d1e87e9660252a3be"></a><!-- doxytag: member="RakPeer::GetTimeoutTime" ref="f6bcc65b6a7c937d1e87e9660252a3be" args="(const SystemAddress target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNetTime RakPeer::GetTimeoutTime           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the Timeout time for the given system. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Target system to get the TimeoutTime for. Pass UNASSIGNED_SYSTEM_ADDRESS to get the default value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Timeout time for a given system. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#52a42188abd07332f3111aa0e70192aa">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="b28534e0a89741d3b98b9e08a55c62b3"></a><!-- doxytag: member="RakPeer::HandleRPCPacket" ref="b28534e0a89741d3b98b9e08a55c62b3" args="(const char *data, int length, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::HandleRPCPacket           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles an RPC packet. This packet has an RPC request. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A packet returned from Receive with the ID ID_RPC </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size of the packet data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The sender of the packet </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on a bad packet or an unregistered function </dd></dl>

</div>
</div><p>
<a class="anchor" name="f181aebf9663297b633a7f0f7afbd74e"></a><!-- doxytag: member="RakPeer::HandleRPCReplyPacket" ref="f181aebf9663297b633a7f0f7afbd74e" args="(const char *data, int length, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::HandleRPCReplyPacket           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Handles an RPC reply packet. The reply packet has data returned from an RPC call. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A packet returned from Receive with the ID ID_RPC </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size of the packet data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The sender of the packet </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="71721eb4963b3aa7d39816d9e21438b7"></a><!-- doxytag: member="RakPeer::IncrementNextSendReceipt" ref="71721eb4963b3aa7d39816d9e21438b7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakPeer::IncrementNextSendReceipt           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next uint32_t that <a class="el" href="classRakPeer.html#cf41cc0dc46e2d9678504eed199a4815" title="Sends a block of data to the specified system that you are connected to.">Send()</a> will return, and increments the value by one <dl class="note" compact><dt><b>Note:</b></dt><dd>If using <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, pass this to forceReceipt in the send function </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next uint32_t that <a class="el" href="classRakPeer.html#cf41cc0dc46e2d9678504eed199a4815" title="Sends a block of data to the specified system that you are connected to.">Send()</a> or SendList will return </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#6950d7bf4b8abd6a13e9743b4324ba6f">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="adcb268bdcd4751c304c8156c28eb66d"></a><!-- doxytag: member="RakPeer::InitializeSecurity" ref="adcb268bdcd4751c304c8156c28eb66d" args="(const char *pubKeyE, const char *pubKeyN, const char *privKeyP, const char *privKeyQ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::InitializeSecurity           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pubKeyE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pubKeyN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>privKeyP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>privKeyQ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Secures connections though a combination of SHA1, AES128, SYN Cookies, and RSA to prevent connection spoofing, replay attacks, data eavesdropping, packet tampering, and MitM attacks. 
<p>
If you accept connections, you must call this for the secure connection to be enabled for incoming connections. If you are connecting to another system, you can call this with public key values for p,q and e before connecting to prevent MitM. Define how many bits are used in RakNetDefines.h with RAKNET_RSA_FACTOR_LIMBS. <dl class="note" compact><dt><b>Note:</b></dt><dd>There is a significant amount of processing and a slight amount of bandwidth overhead for this feature. </dd></dl>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Must be called before Initialize. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pubKeyE</em>&nbsp;</td><td>A pointer to the public keys from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pubKeyN</em>&nbsp;</td><td>A pointer to the public keys from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>privKeyP</em>&nbsp;</td><td>Public key generated from the RSACrypt class. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>privKeyQ</em>&nbsp;</td><td>Public key generated from the RSACrypt class. If the private keys are 0, then a new key will be generated when this function is called</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>the Encryption sample </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#c7f72829da0a08298ac7cfb1486eaf22">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="52ff3b23878d11d8b00473835d44b1f5"></a><!-- doxytag: member="RakPeer::IsActive" ref="52ff3b23878d11d8b00473835d44b1f5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsActive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the network thread is running. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the network thread is running, False otherwise </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#657f140de03d2db27b4cffd3229dc107">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="e1ad09ea9ca5ea8bd4a00f78e22a5abc"></a><!-- doxytag: member="RakPeer::IsBanned" ref="e1ad09ea9ca5ea8bd4a00f78e22a5abc" args="(const char *IP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsBanned           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true or false indicating if a particular IP is banned. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>Dotted IP address. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if IP matches any IPs in the ban list, accounting for any wildcards. False otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3aad41de0447db6585ed2657e748c836">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="ca0cb46f8b48b2f2d5da83377c918064"></a><!-- doxytag: member="RakPeer::IsConnected" ref="ca0cb46f8b48b2f2d5da83377c918064" args="(const AddressOrGUID systemIdentifier, bool includeInProgress=false, bool includeDisconnecting=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsConnected           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includeInProgress</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>includeDisconnecting</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if a particular systemAddress is connected to us. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This can also be made to return true if we are in the process of connecting. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> we are referring to </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includeInProgress</em>&nbsp;</td><td>If true, also return true for connections that are in progress but haven't completed </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>includeDisconnecting</em>&nbsp;</td><td>If true, also return true for connections that are in the process of disconnecting </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This locks a mutex, do not call too frequently during connection attempts with includeInProgress==true or you may cause the attempt to take longer and fail </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if this system is connected and active, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#c0a269d7e31d41214502bc05025e4b86">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="bb93b5dbfb9a7f7d64365340d5516e73"></a><!-- doxytag: member="RakPeer::IsConnectionAttemptPending" ref="bb93b5dbfb9a7f7d64365340d5516e73" args="(const SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsConnectionAttemptPending           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if a particular systemAddress has a pending or in progress connection attempt <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> we are referring to </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#70fb82af25f946ed82a0f4756896af5b">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="4541da876eef1161bd7460f2cbfcc3bd"></a><!-- doxytag: member="RakPeer::IsInSecurityExceptionList" ref="4541da876eef1161bd7460f2cbfcc3bd" args="(const char *ip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsInSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see if a given IP is in the security exception list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>address to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the IP address is found in security exception list, else returns false. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3f4a251109ed1f18e2d7797fb751b41e">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="251f0972c417a8770548a354a10178f5"></a><!-- doxytag: member="RakPeer::IsLocalIP" ref="251f0972c417a8770548a354a10178f5" args="(const char *ip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsLocalIP           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a local IP? Checks if this ip is in the ipList array. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>An</em>&nbsp;</td><td>IP address to check, excluding the port. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if this is one of the IP addresses returned by GetLocalIP </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#16ba7115ab5af3bb961cf35690dd7f2c">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="972f872d20bb187a0bbb92f29d4ae34f"></a><!-- doxytag: member="RakPeer::IsNetworkSimulatorActive" ref="972f872d20bb187a0bbb92f29d4ae34f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::IsNetworkSimulatorActive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if you previously called ApplyNetworkSimulator. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Ture if you previously called ApplyNetworkSimulator. False otherwise. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#0188ac9d8c95fb82d9f7e0a222b4e91f">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="0155271445e2fe26b382080f228df46d"></a><!-- doxytag: member="RakPeer::NumberOfConnections" ref="0155271445e2fe26b382080f228df46d" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short RakPeer::NumberOfConnections           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns how many open connections exist at this time. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of open connections. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#5b008ecfe410e53b2e90be01c6d27a7d">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3e1cda7f2e6b523902b6db6c88ca4e38"></a><!-- doxytag: member="RakPeer::Ping" ref="3e1cda7f2e6b523902b6db6c88ca4e38" args="(const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections, unsigned connectionSocketIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::Ping           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyReplyOnAcceptingConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a ping to the specified unconnected system. 
<p>
The remote system, if it is Initialized, will respond with ID_PONG followed by sizeof(RakNetTime) containing the system time the ping was sent. Default is 4 bytes - See __GET_TIME_64BIT in <a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> System should reply with ID_PONG if it is active <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name. Can be 255.255.255.255 for LAN broadcast. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>onlyReplyOnAcceptingConnections</em>&nbsp;</td><td>Only request a reply if the remote system is accepting connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure (unknown hostname) </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#e6e620155fde9c13a123cc86187b9e49">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="171a26ffc686c3666b169e8972d8e282"></a><!-- doxytag: member="RakPeer::Ping" ref="171a26ffc686c3666b169e8972d8e282" args="(const SystemAddress target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::Ping           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a ping to the specified connected system. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to <a class="el" href="classRakPeer.html#1fbd8608cf1ead14250b293cc6eb9a85" title="Starts the network threads and opens the listen port.">Startup()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to ping </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#77db4b90cc52e41c1e5965462b923c27">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="9968ebdb31bcc7563b035a567046169b"></a><!-- doxytag: member="RakPeer::PushBackPacket" ref="9968ebdb31bcc7563b035a567046169b" args="(Packet *packet, bool pushAtHead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::PushBackPacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pushAtHead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Puts a message back in the receive queue in case you don't want to deal with it immediately. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>The pointer to the packet you want to push back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pushAtHead</em>&nbsp;</td><td>True to push the packet at the start of the queue so that the next receive call returns it. False to push it at the end of the queue. </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Setting pushAtHead to false end makes the packets out of order. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#e4b68058e13bb3ef247dfdee30079063">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="79fddb1f74db30833fc08687c1310ce7"></a><!-- doxytag: member="RakPeer::Receive" ref="79fddb1f74db30833fc08687c1310ce7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPacket.html">Packet</a>* RakPeer::Receive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a message from the incoming message queue. 
<p>
Use <a class="el" href="classRakPeer.html#f68f8d2766b45b6d951dfd62cf349a71" title="Call this to deallocate a message returned by Receive() when you are done handling...">DeallocatePacket()</a> to deallocate the message after you are done with it. User-thread functions, such as RPC calls and the plugin function PluginInterface::Update occur here. <dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no packets are waiting to be handled, otherwise a pointer to a packet. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>COMMON MISTAKE: Be sure to call this in a loop, once per game tick, until it returns 0. If you only process one packet per game tick they will buffer up. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> contains struct <a class="el" href="structPacket.html" title="This represents a user message from another system.">Packet</a>. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#b92ff92041d251011bc166f6abdf119d">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="24be36bb9b57fd85627d89b66b149c50"></a><!-- doxytag: member="RakPeer::RemoveFromSecurityExceptionList" ref="24be36bb9b57fd85627d89b66b149c50" args="(const char *ip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::RemoveFromSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a specific connection previously added via AddToSecurityExceptionList. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ip</em>&nbsp;</td><td>IP address to remove. Pass 0 to remove all IP addresses. * wildcards are supported. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#c4cc2c70b9b6c1ddb6f24ccf5a282e04">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c5c75a11b9732b1061155b730509cb6a"></a><!-- doxytag: member="RakPeer::RemoveRouterInterface" ref="c5c75a11b9732b1061155b730509cb6a" args="(RouterInterface *routerInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::RemoveRouterInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRouterInterface.html">RouterInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>routerInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>This was added without considering proper architecture </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#182a8feaf7813b259028120f0405d69a">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="add1f66541b69c13191bd6b0a7e8daee"></a><!-- doxytag: member="RakPeer::Send" ref="add1f66541b69c13191bd6b0a7e8daee" args="(const RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakPeer::Send           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceipt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a block of data to the specified system that you are connected to. 
<p>
Same as the above version, but takes a BitStream as input. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitStream</em>&nbsp;</td><td>Bitstream to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>Channel to order the messages on, when using ordered or sequenced messages. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>System Address or <a class="el" href="structRakNetGUID.html">RakNetGUID</a> to send this packet to, or in the case of broadcasting, the address not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>COMMON MISTAKE: When writing the first byte, bitStream-&gt;Write((unsigned char) ID_MY_TYPE) be sure it is casted to a byte, and you are not writing a 4 byte enumeration. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3c53433c70462e543664087ac73e5347">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf41cc0dc46e2d9678504eed199a4815"></a><!-- doxytag: member="RakPeer::Send" ref="cf41cc0dc46e2d9678504eed199a4815" args="(const char *data, const int length, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakPeer::Send           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceipt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a block of data to the specified system that you are connected to. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This function only works while the connected. <p>
The first byte should be a message identifier starting at ID_USER_PACKET_ENUM. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Block of data to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Size in bytes of the data to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, the channel to order these on. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Pass either a <a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> structure or a <a class="el" href="structRakNetGUID.html">RakNetGUID</a> structure. Use UNASSIGNED_SYSTEM_ADDRESS or to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#36b7517ac2e6e420736ed8758c125397">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="70b2284bc6d741be7429570f3f3222bf"></a><!-- doxytag: member="RakPeer::SendList" ref="70b2284bc6d741be7429570f3f3222bf" args="(const char **data, const int *lengths, const int numParameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceipt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RakPeer::SendList           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>numParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceipt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends multiple blocks of data, concatenating them automatically. 
<p>
This is equivalent to: <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> bs; bs.WriteAlignedBytes(block1, blockLength1); bs.WriteAlignedBytes(block2, blockLength2); bs.WriteAlignedBytes(block3, blockLength3); Send(&amp;bs, ...)<p>
This function only works when connected. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>An array of pointers to blocks of data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lengths</em>&nbsp;</td><td>An array of integers indicating the length of each block of data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numParameters</em>&nbsp;</td><td>Length of the arrays data and lengths </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>Priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliably to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>Channel to order the messages on, when using ordered or sequenced messages. Messages are only ordered relative to other messages on the same stream. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>System Address or <a class="el" href="structRakNetGUID.html">RakNetGUID</a> to send this packet to, or in the case of broadcasting, the address not to send it to. Use UNASSIGNED_SYSTEM_ADDRESS to specify none. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakPeer.html#79fddb1f74db30833fc08687c1310ce7" title="Gets a message from the incoming message queue.">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Doesn't support the router plugin. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#1295b843f4717c95c0a30cbb97425773">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="888819dc988a3282c41db84ee0a00b6e"></a><!-- doxytag: member="RakPeer::SendLoopback" ref="888819dc988a3282c41db84ee0a00b6e" args="(const char *data, const int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SendLoopback           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Send" to yourself rather than a remote system. 
<p>
The message will be processed through the plugins and returned to the game as usual. This function works anytime <dl class="note" compact><dt><b>Note:</b></dt><dd>The first byte should be a message identifier starting at ID_USER_PACKET_ENUM </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Block of data to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Size in bytes of the data to send. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#aa2ae363bd5a7f8f631bf8b949681df1">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="babf4af38512fb961f29cfc284dfeb22"></a><!-- doxytag: member="RakPeer::SendTTL" ref="babf4af38512fb961f29cfc284dfeb22" args="(const char *host, unsigned short remotePort, int ttl, unsigned connectionSocketIndex=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SendTTL           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message to a host, with the IP socket option TTL set to 3. 
<p>
This message will not reach the host, but will open the router. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>The address of the remote host in dotted notation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>The port number to send to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ttl</em>&nbsp;</td><td>Max hops of datagram, set to 3 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>userConnectionSocketIndex. </td></tr>
  </table>
</dl>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>Used for NAT-Punchthrough </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#8ba581f78b9065affbab166654ff4ad8">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="e20dde8c8397a680c70bdc9f6639ca58"></a><!-- doxytag: member="RakPeer::SetCompileFrequencyTable" ref="e20dde8c8397a680c70bdc9f6639ca58" args="(bool doCompile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetCompileFrequencyTable           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doCompile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables or disables frequency table tracking. 
<p>
This is required to get a frequency table, which is used in <a class="el" href="classRakPeer.html#f3b47a3087903697acac977e3525b8d9" title="This is an optional function to generate the compression layer based on the input...">GenerateCompressionLayer()</a>. This value persists between connect calls and defaults to false (no frequency tracking). <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>You can call this at any time - however you SHOULD only call it when disconnected. Otherwise you will only trackpart of the values sent over the network. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>doCompile</em>&nbsp;</td><td>True to enable tracking </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#461f51d0c7e15a6821f1252133f75d65">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="a6daafe75bfe4882aa46f32cb753378c"></a><!-- doxytag: member="RakPeer::SetIncomingPassword" ref="a6daafe75bfe4882aa46f32cb753378c" args="(const char *passwordData, int passwordDataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetIncomingPassword           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the password for the incoming connections. 
<p>
The password must match in the call to Connect (defaults to none). Pass 0 to passwordData to specify no password. This is a way to set a low level password for all incoming connections. To selectively reject connections, implement your own scheme using <a class="el" href="classRakPeer.html#4a7c586a8be0d977354a3cfd09bab6b7" title="Close the connection to another host (if we initiated the connection it will disconnect...">CloseConnection()</a> to remove unwanted connections. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that incoming connections must match. This can be just a password, or can be a stream of data. Specify 0 for no password data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#6156083e485f036bc76fb1f17b249f7d">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="7aa96b5a724a9cfb9b4c53e84ccdce04"></a><!-- doxytag: member="RakPeer::SetLimitIPConnectionFrequency" ref="7aa96b5a724a9cfb9b4c53e84ccdce04" args="(bool b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetLimitIPConnectionFrequency           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>b</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable allowing frequent connections from the same IP adderss. 
<p>
This is a security measure which is disabled by default, but can be set to true to prevent attackers from using up all connection slots. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>True to limit connections from the same ip to at most 1 per 100 milliseconds. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#3b92a0c86c2efcc79453eeecb68827fc">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="d2004ca40f0a88ca24f70196321d48c8"></a><!-- doxytag: member="RakPeer::SetMaximumIncomingConnections" ref="d2004ca40f0a88ca24f70196321d48c8" args="(unsigned short numberAllowed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetMaximumIncomingConnections           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>numberAllowed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the maximum number of incoming connections allowed. 
<p>
If the number of incoming connections is less than the number of players currently connected, no more players will be allowed to connect. If this is greater than the maximum number of peers allowed, it will be reduced to the maximum number of peers allowed.<p>
Defaults to 0, meaning by default, nobody can connect to you <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberAllowed</em>&nbsp;</td><td>Maximum number of incoming connections allowed. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#43ab3da8e2a95f71f232f95a2593ba9f">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="8324e15260b26b92abb204ed9f04ff57"></a><!-- doxytag: member="RakPeer::SetOccasionalPing" ref="8324e15260b26b92abb204ed9f04ff57" args="(bool doPing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetOccasionalPing           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doPing</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ping the remote systems every so often, or not. Can be called anytime. By default this is true if GET_TIME_SPIKE_LIMIT is non-zero from RakNetDefines, false otherwise It would be true by default to prevent timestamp drift, since in the event of a clock spike, the timestamp deltas would no longer be accurate <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>doPing</em>&nbsp;</td><td>True to start occasional pings. False to stop them. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#1eebc5c00cb8ca317aa350c90161eca6">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="7d7601d2d7114c454829c655dc9e79c7"></a><!-- doxytag: member="RakPeer::SetOfflinePingResponse" ref="7d7601d2d7114c454829c655dc9e79c7" args="(const char *data, const unsigned int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetOfflinePingResponse           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the data to send along with a LAN server discovery or offline ping reply. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Block of data to send, or 0 for none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>Length of the data in bytes, or 0 for none </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><em>length</em> should be under 400 bytes, as a security measure against flood attacks </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Ping.cpp </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#7ccf08b2d04ef007a0719dfa4f4dadc5">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="43eacd3c80d27df603fe9be59174359b"></a><!-- doxytag: member="RakPeer::SetPerConnectionOutgoingBandwidthLimit" ref="43eacd3c80d27df603fe9be59174359b" args="(unsigned maxBitsPerSecond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetPerConnectionOutgoingBandwidthLimit           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>maxBitsPerSecond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limits how much outgoing bandwidth can be used per-connection. This limit does not apply to the sum of all connections! Exceeding the limit queues up outgoing traffic. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxBitsPerSecond</em>&nbsp;</td><td>Maximum bits per second to send. Use 0 for unlimited (default). Once set, it takes effect immedately and persists until called again. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#541a79a2e6ab96ee6e625c15b626a088">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="3a007c320065e2e390bdfe91a54bdfb3"></a><!-- doxytag: member="RakPeer::SetRouterInterface" ref="3a007c320065e2e390bdfe91a54bdfb3" args="(RouterInterface *routerInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetRouterInterface           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRouterInterface.html">RouterInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>routerInterface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
------------------------------------------- Deprecated ------------------------- 
<p>
------------------------------------------- Deprecated -------------------------  <dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000023">Deprecated:</a></b></dt><dd>This was added without considering proper architecture </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#6204c74161a09c737b1ddc03579f971e">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="c1cb3f6aeaa842c721bbe4a3d74c3d5d"></a><!-- doxytag: member="RakPeer::SetSplitMessageProgressInterval" ref="c1cb3f6aeaa842c721bbe4a3d74c3d5d" args="(int interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetSplitMessageProgressInterval           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads. 
<p>
ID_DOWNLOAD_PROGRESS is returned to indicate a new partial message chunk, roughly the MTU size, has arrived. As it can be slow or cumbersome to get this notification for every chunk, you can set the interval at which it is returned. Defaults to 0 (never return this notification). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>How many messages to use as an interval before a download progress notification is returned. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#471f44e797e0cf73a8ae8ec1935ff767">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="e07b0a50700a8c79d9c04360acf9945e"></a><!-- doxytag: member="RakPeer::SetTimeoutTime" ref="e07b0a50700a8c79d9c04360acf9945e" args="(RakNetTime timeMS, const SystemAddress target)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetTimeoutTime           </td>
          <td>(</td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timeMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message. 
<p>
Default time is 10,000 or 10 seconds in release and 30,000 or 30 seconds in debug. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeMS</em>&nbsp;</td><td>Time, in MS </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td><a class="el" href="structSystemAddress.html" title="Network address for a system.">SystemAddress</a> structure of the target system. Pass UNASSIGNED_SYSTEM_ADDRESS for all systems. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#be44fc861e51716cf3499fafba7d66ac">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="699049419ad22610064ef595cde4560e"></a><!-- doxytag: member="RakPeer::SetUnreliableTimeout" ref="699049419ad22610064ef595cde4560e" args="(RakNetTime timeoutMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::SetUnreliableTimeout           </td>
          <td>(</td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timeoutMS</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set how long to wait before giving up on sending an unreliable message. Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutMS</em>&nbsp;</td><td>How many ms to wait before simply not sending an unreliable message. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#146669e0a5e78317b539fa22d9704df0">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="62cbbeb26969bf86d168e05a1643ad47"></a><!-- doxytag: member="RakPeer::SetUserUpdateThread" ref="62cbbeb26969bf86d168e05a1643ad47" args="(void(*_userUpdateThreadPtr)(RakPeerInterface *, void *), void *_userUpdateThreadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakPeer::SetUserUpdateThread           </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *, void *)&nbsp;</td>
          <td class="paramname"> <em>_userUpdateThreadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userUpdateThreadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you need code to run in the same thread as RakNet's update thread, this function can be used for that <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_userUpdateThreadPtr</em>&nbsp;</td><td>C callback function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_userUpdateThreadData</em>&nbsp;</td><td>Passed to C callback function </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#5111206588c746a198c2fb76e61c308a">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="303003eed8c97558f6c9b2657f76a7ae"></a><!-- doxytag: member="RakPeer::ShiftIncomingTimestamp" ref="303003eed8c97558f6c9b2657f76a7ae" args="(unsigned char *data, SystemAddress systemAddress) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::ShiftIncomingTimestamp           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adjust the timestamp of the incoming packet to be relative to this system. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Data in the incoming packet. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Sender of the incoming packet. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab69808cd87c19f1800ac36d8c8e584c"></a><!-- doxytag: member="RakPeer::Shutdown" ref="ab69808cd87c19f1800ac36d8c8e584c" args="(unsigned int blockDuration, unsigned char orderingChannel=0, PacketPriority disconnectionNotificationPriority=LOW_PRIORITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakPeer::Shutdown           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>blockDuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>disconnectionNotificationPriority</em> = <code>LOW_PRIORITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops the network threads and closes all connections. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blockDuration</em>&nbsp;</td><td>Wait time(milli seconds) for all remaining messages to go out, including ID_DISCONNECTION_NOTIFICATION. If 0, it doesn't wait at all. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>Channel on which ID_DISCONNECTION_NOTIFICATION will be sent, if blockDuration &gt; 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>disconnectionNotificationPriority</em>&nbsp;</td><td>Priority of sending ID_DISCONNECTION_NOTIFICATION. If set to 0, the disconnection notification won't be sent. </td></tr>
  </table>
</dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#e78ac80e7120531ee1a52eb7342278d0">RakPeerInterface</a>.</p>

</div>
</div><p>
<a class="anchor" name="1fbd8608cf1ead14250b293cc6eb9a85"></a><!-- doxytag: member="RakPeer::Startup" ref="1fbd8608cf1ead14250b293cc6eb9a85" args="(unsigned short maxConnections, int _threadSleepTimer, SocketDescriptor *socketDescriptors, unsigned socketDescriptorCount, int threadPriority=&#45;99999)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakPeer::Startup           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>maxConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>_threadSleepTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSocketDescriptor.html">SocketDescriptor</a> *&nbsp;</td>
          <td class="paramname"> <em>socketDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>socketDescriptorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threadPriority</em> = <code>-99999</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the network threads and opens the listen port. 
<p>
You must call this before calling <a class="el" href="classRakPeer.html#c7ba51ef72df78a7da4b7e6d5e2c8276" title="Connect to the specified host (ip or domain name) and server port.">Connect()</a>. <dl class="note" compact><dt><b>Note:</b></dt><dd>Multiple calls while already active are ignored. To call this function again with different settings, you must first call <a class="el" href="classRakPeer.html#ab69808cd87c19f1800ac36d8c8e584c" title="Stops the network threads and closes all connections.">Shutdown()</a>. <p>
Call SetMaximumIncomingConnections if you want to accept incoming connections. <p>
Set _RAKNET_THREADSAFE in RakNetDefines.h if you want to call <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> functions from multiple threads (not recommended, as it is much slower and <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> is already asynchronous). </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxConnections</em>&nbsp;</td><td>Maximum number of connections between this instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a> and another instance of <a class="el" href="classRakPeer.html" title="Main interface for network communications.">RakPeer</a>. Required so that the network can preallocate and for thread safety. A pure client would set this to 1. A pure server would set it to the number of allowed clients.A hybrid would set it to the sum of both types of connections. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localPort</em>&nbsp;</td><td>Port to listen for connections on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_threadSleepTimer</em>&nbsp;</td><td>Time in milliseconds for the thread to Sleep in each internal update cycle. With new congestion control, the best results will be obtained by passing 10. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketDescriptors</em>&nbsp;</td><td>An array of <a class="el" href="structSocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> structures to force <a class="el" href="namespaceRakNet.html" title="Forward declaration.">RakNet</a> to listen on a particular IP address or port (or both). Each <a class="el" href="structSocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> will represent one unique socket. Do not pass redundant structures. To listen on a specific port, you can pass SocketDescriptor(myPort,0); for a server. For a client, it is usually OK to pass SocketDescriptor(); </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketDescriptorCount</em>&nbsp;</td><td>The size of the <em>socketDescriptors</em> array. Pass 1 if you are not sure what to pass. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadPriority</em>&nbsp;</td><td>Passed to the thread creation routine. Use THREAD_PRIORITY_NORMAL for Windows. For Linux based systems, you MUST pass something reasonable based on the thread priorities for your application. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False on failure (can't create socket or thread), true on success. </dd></dl>

<p>Implements <a class="el" href="classRakPeerInterface.html#5888ca97f61ec4147913ac9ec902688b">RakPeerInterface</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="8dc645e7f22a90abe45dfc3fdc74044f"></a><!-- doxytag: member="RakPeer::allowConnectionResponseIPMigration" ref="8dc645e7f22a90abe45dfc3fdc74044f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classRakPeer.html#8dc645e7f22a90abe45dfc3fdc74044f">RakPeer::allowConnectionResponseIPMigration</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How long it has been since things were updated by a call to receiveUpdate thread uses this to determine how long to sleep for. 
<p>
True to allow connection accepted packets from anyone. False to only allow these packets from servers we requested a connection to. 
</div>
</div><p>
<a class="anchor" name="ba1ca9377af6817e35620c47bc89887f"></a><!-- doxytag: member="RakPeer::bytesSentPerSecond" ref="ba1ca9377af6817e35620c47bc89887f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classRakPeer.html#ba1ca9377af6817e35620c47bc89887f">RakPeer::bytesSentPerSecond</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The list of people we have tried to connect to recently. 
<p>
Data that both the client and the server needs 
</div>
</div><p>
<a class="anchor" name="8ac75ac0847890a84a490143e7499dd8"></a><!-- doxytag: member="RakPeer::maximumIncomingConnections" ref="8ac75ac0847890a84a490143e7499dd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short <a class="el" href="classRakPeer.html#8ac75ac0847890a84a490143e7499dd8">RakPeer::maximumIncomingConnections</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the maximum number of peers able to connect, including reserved connection slots for pings, etc. 
<p>
Store the maximum incoming connection allowed 
</div>
</div><p>
<a class="anchor" name="af0f4145d68e3aab994aa58dabd8047e"></a><!-- doxytag: member="RakPeer::maximumNumberOfPeers" ref="af0f4145d68e3aab994aa58dabd8047e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* unsigned short <a class="el" href="classRakPeer.html#af0f4145d68e3aab994aa58dabd8047e">RakPeer::maximumNumberOfPeers</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Store the maximum number of peers allowed to connect. 
<p>
Do we occasionally ping the other systems? 
</div>
</div><p>
<a class="anchor" name="fac48c9f0bb054679a435ea8eb309181"></a><!-- doxytag: member="RakPeer::remoteSystemList" ref="fac48c9f0bb054679a435ea8eb309181" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RemoteSystemStruct* <a class="el" href="classRakPeer.html#fac48c9f0bb054679a435ea8eb309181">RakPeer::remoteSystemList</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is an array of pointers to RemoteSystemStruct This allows us to preallocate the list when starting, so we don't have to allocate or delete at runtime. Another benefit is that is lets us add and remove active players simply by setting systemAddress and moving elements in the list by copying pointers variables without affecting running threads, even if they are in the reliability layer 
</div>
</div><p>
<a class="anchor" name="576b14709afe3ab4084b0bba460d6cb7"></a><!-- doxytag: member="RakPeer::sendReceiptSerialMutex" ref="576b14709afe3ab4084b0bba460d6cb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleMutex.html">SimpleMutex</a> <a class="el" href="classRakPeer.html#576b14709afe3ab4084b0bba460d6cb7">RakPeer::sendReceiptSerialMutex</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is used to return a number to the user when they call Send identifying the message This number will be returned back with ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS and is only returned with the reliability types that contain RECEIPT in the name 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>d:/RakNet-3.x/Source/<a class="el" href="RakPeer_8h.html">RakPeer.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Fri Jul 22 08:28:35 2011 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
