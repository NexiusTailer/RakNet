<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RakNet: AutoRPC Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>AutoRPC Class Reference<br>
<small>
[<a class="el" href="group__AUTO__RPC__GROUP.html">AutoRPC</a>]</small>
</h1><!-- doxytag: class="AutoRPC" --><!-- doxytag: inherits="PluginInterface" --><code>#include &lt;AutoRPC.h&gt;</code>
<p>
<p>Inheritance diagram for AutoRPC:
<p><center><img src="classAutoRPC.png" usemap="#AutoRPC_map" border="0" alt=""></center>
<map name="AutoRPC_map">
<area href="classPluginInterface.html" alt="PluginInterface" shape="rect" coords="0,0,97,24">
</map>
<a href="classAutoRPC-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0427b044356ff28cad3d56d1b975321e"></a><!-- doxytag: member="AutoRPC::AutoRPC" ref="0427b044356ff28cad3d56d1b975321e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#0427b044356ff28cad3d56d1b975321e">AutoRPC</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="26dbb7d3f6e21137be19b22c60157f04"></a><!-- doxytag: member="AutoRPC::~AutoRPC" ref="26dbb7d3f6e21137be19b22c60157f04" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#26dbb7d3f6e21137be19b22c60157f04">~AutoRPC</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#2fed277e21a343bb9861a52cf80680e4">SetNetworkIDManager</a> (<a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *idMan)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#8f1c81797ade31cfb33b77bfb9fc5580">RegisterFunction</a> (const char *uniqueIdentifier, void *functionPtr, bool isObjectMember)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#868ee4d14ee2437b42166013f1a9125a">UnregisterFunction</a> (const char *uniqueIdentifier, bool isObjectMember)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp</a> (RakNetTime timeStamp)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams</a> (<a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress</a> (<a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress, bool broadcast)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject</a> (NetworkID networkID)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">RakNetTime&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#4ca2f481817407b5e4a0a24ba5a7d16e">GetLastSenderTimestamp</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#e0fe8ce3ec4eda4bbcba993217cc1429">GetLastSenderAddress</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5b297c1e5d4ee2ab50120a122dee8cae"></a><!-- doxytag: member="AutoRPC::GetRakPeer" ref="5b297c1e5d4ee2ab50120a122dee8cae" args="(void) const " -->
<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#5b297c1e5d4ee2ab50120a122dee8cae">GetRakPeer</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the instance of <a class="el" href="classRakPeer.html">RakPeer</a> this plugin was attached to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#62a43b941b86174a3038b0be945aaf9e">GetCurrentExecution</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call</a> (const char *uniqueIdentifier)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#a173db113b9bbda6520e7123eec7338c">Call</a> (const char *uniqueIdentifier, P1 p1, bool es1=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#b390629a4dfd66d63bd90947b84a14aa">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, bool es1=true, bool es2=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#fe4146aa640d1816aa9e1060909d2b04">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, bool es1=true, bool es2=true, bool es3=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3, class P4&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#f5d1cc788e2b9eb9bb2fa9fca2f47b6e">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, bool es1=true, bool es2=true, bool es3=true, bool es4=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3, class P4, class P5&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#e5a2794e7c06c2e460d8387764498502">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3, class P4, class P5, class P6&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#a2913823c6c19acda23d1da6360c05d3">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3, class P4, class P5, class P6, class P7&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#2d12afa6f5efd11a69225bccccb44d5b">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true, bool es7=true)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#f9f86f60be717ab6b512d4ce62723dbc">Call</a> (const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true, bool es7=true, bool es8=true)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#f9fa2bcc57dcbd5dd257914bfc5894c1">OnAttach</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual PluginReceiveResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#2f9acc244d1ff0bc6290684b4eb1b23f">OnReceive</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structPacket.html">Packet</a> *packet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#fc6da580e907279d1b5a25866dd65258">OnCloseConnection</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer, <a class="el" href="structSystemAddress.html">SystemAddress</a> systemAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutoRPC.html#8a55cc4da36c5a9d941eff869c92b993">OnShutdown</a> (<a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *peer)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The <a class="el" href="classAutoRPC.html">AutoRPC</a> plugin allows you to call remote functions as if they were local functions, using the standard function call syntax No serialization or deserialization is needed. Advantages are that this is easier to use than regular RPC system. Disadvantages is that all parameters must be passable on the stack using memcpy (shallow copy). For other types of parameters, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> Use the old system, or regular message passing, if you need greater flexibility 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2fed277e21a343bb9861a52cf80680e4"></a><!-- doxytag: member="AutoRPC::SetNetworkIDManager" ref="2fed277e21a343bb9861a52cf80680e4" args="(NetworkIDManager *idMan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::SetNetworkIDManager           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> *&nbsp;</td>
          <td class="paramname"> <em>idMan</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the network ID manager to use for object lookup Required to call C++ object member functions via <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>idMan</em>&nbsp;</td><td>Pointer to the network ID manager to use </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8f1c81797ade31cfb33b77bfb9fc5580"></a><!-- doxytag: member="AutoRPC::RegisterFunction" ref="8f1c81797ade31cfb33b77bfb9fc5580" args="(const char *uniqueIdentifier, void *functionPtr, bool isObjectMember)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::RegisterFunction           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>functionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isObjectMember</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registers a function pointer to be callable given an identifier for the pointer <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueIdentifier</em>&nbsp;</td><td>String identifying the function. Recommended that this is the name of the function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>functionPtr</em>&nbsp;</td><td>Pointer to the function. For C, just pass the name of the function. For C++, use ARPC_REGISTER_CPP_FUNCTION </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isObjectMember</em>&nbsp;</td><td>false if a C function. True if a member function of an object (C++) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on uniqueIdentifier already used </dd></dl>

</div>
</div><p>
<a class="anchor" name="868ee4d14ee2437b42166013f1a9125a"></a><!-- doxytag: member="AutoRPC::UnregisterFunction" ref="868ee4d14ee2437b42166013f1a9125a" args="(const char *uniqueIdentifier, bool isObjectMember)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::UnregisterFunction           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isObjectMember</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unregisters a function pointer to be callable given an identifier for the pointer <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>uniqueIdentifier</em>&nbsp;</td><td>String identifying the function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>isObjectMember</em>&nbsp;</td><td>false if a C function. True if a member function of an object (C++) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on function was not previously or is not currently registered. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e252381d692421ee854b86d7ea856a73"></a><!-- doxytag: member="AutoRPC::SetTimestamp" ref="e252381d692421ee854b86d7ea856a73" args="(RakNetTime timeStamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::SetTimestamp           </td>
          <td>(</td>
          <td class="paramtype">RakNetTime&nbsp;</td>
          <td class="paramname"> <em>timeStamp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send or stop sending a timestamp with all following calls to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> Use <a class="el" href="classAutoRPC.html#4ca2f481817407b5e4a0a24ba5a7d16e">GetLastSenderTimestamp()</a> to read the timestamp. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeStamp</em>&nbsp;</td><td>Non-zero to pass this timestamp using the ID_TIMESTAMP system. 0 to clear passing a timestamp. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2a91f35d99a253eadf494129565719e2"></a><!-- doxytag: member="AutoRPC::SetSendParams" ref="2a91f35d99a253eadf494129565719e2" args="(PacketPriority priority, PacketReliability reliability, char orderingChannel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::SetSendParams           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set parameters to pass to <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> for all following calls to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> Deafults to HIGH_PRIORITY, RELIABLE_ORDERED, ordering channel 0 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>See <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>See <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>See <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bc3c27a77a8ff9ead0f077a32a6d7903"></a><!-- doxytag: member="AutoRPC::SetRecipientAddress" ref="bc3c27a77a8ff9ead0f077a32a6d7903" args="(SystemAddress systemAddress, bool broadcast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::SetRecipientAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set system to send to for all following calls to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> Defaults to UNASSIGNED_SYSTEM_ADDRESS, broadcast=true <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>See <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>See <a class="el" href="classRakPeer.html#3acee6622f9526d877fed911669377be">RakPeer::Send()</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c55e6112f076ba052c47b70a68fdd1cf"></a><!-- doxytag: member="AutoRPC::SetRecipientObject" ref="c55e6112f076ba052c47b70a68fdd1cf" args="(NetworkID networkID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::SetRecipientObject           </td>
          <td>(</td>
          <td class="paramtype">NetworkID&nbsp;</td>
          <td class="paramname"> <em>networkID</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the NetworkID to pass for all following calls to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> Defaults to UNASSIGNED_NETWORK_ID (none) If set, the remote function will be considered a C++ function, e.g. an object member function If set to UNASSIGNED_NETWORK_ID (none), the remote function will be considered a C function If this is set incorrectly, you will get back either RPC_ERROR_CALLING_C_AS_CPP or RPC_ERROR_CALLING_CPP_AS_C <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classNetworkIDManager.html">NetworkIDManager</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>networkID</em>&nbsp;</td><td>Returned from <a class="el" href="classNetworkIDObject.html#1d98d33a63964e2c7b566e472c121a6d">NetworkIDObject::GetNetworkID()</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3e411af4ff34c04877a8ff11c806420"></a><!-- doxytag: member="AutoRPC::SetOutgoingExtraData" ref="d3e411af4ff34c04877a8ff11c806420" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> * AutoRPC::SetOutgoingExtraData           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write extra data to pass for all following calls to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> Use BitStream::Reset to clear extra data. Don't forget to do this or you will waste bandwidth. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A bitstream you can write to to send extra data with each following call to <a class="el" href="classAutoRPC.html#d13408eb5fd489d1ae9cced1a0acd6cf">Call()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ca2f481817407b5e4a0a24ba5a7d16e"></a><!-- doxytag: member="AutoRPC::GetLastSenderTimestamp" ref="4ca2f481817407b5e4a0a24ba5a7d16e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNetTime AutoRPC::GetLastSenderTimestamp           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the last received function call has a timestamp included, it is stored and can be retrieved with this function. <dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the last call did not have a timestamp, else non-zero </dd></dl>

</div>
</div><p>
<a class="anchor" name="e0fe8ce3ec4eda4bbcba993217cc1429"></a><!-- doxytag: member="AutoRPC::GetLastSenderAddress" ref="e0fe8ce3ec4eda4bbcba993217cc1429" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSystemAddress.html">SystemAddress</a> AutoRPC::GetLastSenderAddress           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the system address of the last system to send us a received function call Equivalent to the old system <a class="el" href="structRPCParameters.html#1a8b93991b3400a605c438ea01ba9f3d">RPCParameters::sender</a> <dl class="return" compact><dt><b>Returns:</b></dt><dd>Last system to send an RPC call using this system </dd></dl>

</div>
</div><p>
<a class="anchor" name="62a43b941b86174a3038b0be945aaf9e"></a><!-- doxytag: member="AutoRPC::GetCurrentExecution" ref="62a43b941b86174a3038b0be945aaf9e" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * AutoRPC::GetCurrentExecution           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the currently running RPC call identifier, set from RegisterFunction::uniqueIdentifier Returns an empty string "" if none <dl class="return" compact><dt><b>Returns:</b></dt><dd>which RPC call is currently running </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed9db7b981b8cf5a48ace1664d329d45"></a><!-- doxytag: member="AutoRPC::GetIncomingExtraData" ref="ed9db7b981b8cf5a48ace1664d329d45" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> * AutoRPC::GetIncomingExtraData           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bitstream written to via <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a>. Data is updated with each incoming function call <dl class="return" compact><dt><b>Returns:</b></dt><dd>A bitstream you can read from with extra data that was written with <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="d13408eb5fd489d1ae9cced1a0acd6cf"></a><!-- doxytag: member="AutoRPC::Call" ref="d13408eb5fd489d1ae9cced1a0acd6cf" args="(const char *uniqueIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>

</div>
</div><p>
<a class="anchor" name="a173db113b9bbda6520e7123eec7338c"></a><!-- doxytag: member="AutoRPC::Call" ref="a173db113b9bbda6520e7123eec7338c" args="(const char *uniqueIdentifier, P1 p1, bool es1=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b390629a4dfd66d63bd90947b84a14aa"></a><!-- doxytag: member="AutoRPC::Call" ref="b390629a4dfd66d63bd90947b84a14aa" args="(const char *uniqueIdentifier, P1 p1, P2 p2, bool es1=true, bool es2=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe4146aa640d1816aa9e1060909d2b04"></a><!-- doxytag: member="AutoRPC::Call" ref="fe4146aa640d1816aa9e1060909d2b04" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, bool es1=true, bool es2=true, bool es3=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f5d1cc788e2b9eb9bb2fa9fca2f47b6e"></a><!-- doxytag: member="AutoRPC::Call" ref="f5d1cc788e2b9eb9bb2fa9fca2f47b6e" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, bool es1=true, bool es2=true, bool es3=true, bool es4=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3, class P4&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es4</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5a2794e7c06c2e460d8387764498502"></a><!-- doxytag: member="AutoRPC::Call" ref="e5a2794e7c06c2e460d8387764498502" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3, class P4, class P5&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&nbsp;</td>
          <td class="paramname"> <em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es4</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es5</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a2913823c6c19acda23d1da6360c05d3"></a><!-- doxytag: member="AutoRPC::Call" ref="a2913823c6c19acda23d1da6360c05d3" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3, class P4, class P5, class P6&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&nbsp;</td>
          <td class="paramname"> <em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P6&nbsp;</td>
          <td class="paramname"> <em>p6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es4</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es5</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es6</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2d12afa6f5efd11a69225bccccb44d5b"></a><!-- doxytag: member="AutoRPC::Call" ref="2d12afa6f5efd11a69225bccccb44d5b" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true, bool es7=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3, class P4, class P5, class P6, class P7&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&nbsp;</td>
          <td class="paramname"> <em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P6&nbsp;</td>
          <td class="paramname"> <em>p6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P7&nbsp;</td>
          <td class="paramname"> <em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es4</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es5</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es6</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es7</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9f86f60be717ab6b512d4ce62723dbc"></a><!-- doxytag: member="AutoRPC::Call" ref="f9f86f60be717ab6b512d4ce62723dbc" args="(const char *uniqueIdentifier, P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, P7 p7, P8 p8, bool es1=true, bool es2=true, bool es3=true, bool es4=true, bool es5=true, bool es6=true, bool es7=true, bool es8=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class P1, class P2, class P3, class P4, class P5, class P6, class P7, class P8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool AutoRPC::Call           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>uniqueIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P1&nbsp;</td>
          <td class="paramname"> <em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2&nbsp;</td>
          <td class="paramname"> <em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P3&nbsp;</td>
          <td class="paramname"> <em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P4&nbsp;</td>
          <td class="paramname"> <em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P5&nbsp;</td>
          <td class="paramname"> <em>p5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P6&nbsp;</td>
          <td class="paramname"> <em>p6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P7&nbsp;</td>
          <td class="paramname"> <em>p7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P8&nbsp;</td>
          <td class="paramname"> <em>p8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es1</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es2</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es3</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es4</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es5</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es6</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es7</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>es8</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls a remote function, using whatever was last passed to <a class="el" href="classAutoRPC.html#e252381d692421ee854b86d7ea856a73">SetTimestamp()</a>, <a class="el" href="classAutoRPC.html#2a91f35d99a253eadf494129565719e2">SetSendParams()</a>, <a class="el" href="classAutoRPC.html#bc3c27a77a8ff9ead0f077a32a6d7903">SetRecipientAddress()</a>, and <a class="el" href="classAutoRPC.html#c55e6112f076ba052c47b70a68fdd1cf">SetRecipientObject()</a> Passed parameter(s), if any, are passed via memcpy and pushed on the stack for the remote function <dl class="note" compact><dt><b>Note:</b></dt><dd>This ONLY works with variables that are passable via memcpy! If you need more flexibility, use <a class="el" href="classAutoRPC.html#d3e411af4ff34c04877a8ff11c806420">SetOutgoingExtraData()</a> and <a class="el" href="classAutoRPC.html#ed9db7b981b8cf5a48ace1664d329d45">GetIncomingExtraData()</a> <p>
The this pointer, for this instance of <a class="el" href="classAutoRPC.html">AutoRPC</a>, is pushed as the last parameter on the stack. See AutoRPCSample.ccp for an example of this </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>es1</em>&nbsp;</td><td>Endian swap parameter 1..x if necessary. Requires __BITSTREAM_NATIVE_END is undefined in RakNetDefines.h </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f9fa2bcc57dcbd5dd257914bfc5894c1"></a><!-- doxytag: member="AutoRPC::OnAttach" ref="f9fa2bcc57dcbd5dd257914bfc5894c1" args="(RakPeerInterface *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::OnAttach           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when the interface is attached <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#9124155ea27bf6c50801350d21173d68">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="2f9acc244d1ff0bc6290684b4eb1b23f"></a><!-- doxytag: member="AutoRPC::OnReceive" ref="2f9acc244d1ff0bc6290684b4eb1b23f" args="(RakPeerInterface *peer, Packet *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PluginReceiveResult AutoRPC::OnReceive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPacket.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
OnReceive is called for every packet. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>the packet that is being returned to the user </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True to allow the game and other plugins to get this message, false to absorb it </dd></dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#633dcfc264e4309c41f0cfeb84b4840a">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="fc6da580e907279d1b5a25866dd65258"></a><!-- doxytag: member="AutoRPC::OnCloseConnection" ref="fc6da580e907279d1b5a25866dd65258" args="(RakPeerInterface *peer, SystemAddress systemAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::OnCloseConnection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when a connection is dropped because the user called <a class="el" href="classRakPeer.html#05e43a9ba3b85f1000adb2f1e9551000">RakPeer::CloseConnection()</a> for a particular system <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The system whose connection was closed </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#da6d76a81fb6ea6dd8422c3ed5c9baff">PluginInterface</a>.
</div>
</div><p>
<a class="anchor" name="8a55cc4da36c5a9d941eff869c92b993"></a><!-- doxytag: member="AutoRPC::OnShutdown" ref="8a55cc4da36c5a9d941eff869c92b993" args="(RakPeerInterface *peer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutoRPC::OnShutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakPeerInterface.html">RakPeerInterface</a> *&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called when <a class="el" href="classRakPeer.html">RakPeer</a> is shutdown <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>peer</em>&nbsp;</td><td>the instance of <a class="el" href="classRakPeer.html">RakPeer</a> that is calling Receive </td></tr>
  </table>
</dl>

<p>
Reimplemented from <a class="el" href="classPluginInterface.html#0983119975a8bb9c726b8a006c089dc2">PluginInterface</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>C:/RakNet/Source/<a class="el" href="AutoRPC_8h.html">AutoRPC.h</a><li>C:/RakNet/Source/AutoRPC.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Mon Mar 31 11:15:01 2008 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1-p1 </small></address>
</body>
</html>
